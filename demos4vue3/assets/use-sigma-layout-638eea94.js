import{M as xt}from"./relation-graph-28379630.js";import{d as Ut,r as Ot,o as It,a as Rt,c as Ct,b as je,e as Tt,w as jt,u as Pt,p as zt,j as Wt}from"./index-f7176e57.js";import{_ as Kt}from"./_plugin-vue_export-helper-c27b6911.js";var Se={},Bt={get exports(){return Se},set exports(i){Se=i}},le=typeof Reflect=="object"?Reflect:null,He=le&&typeof le.apply=="function"?le.apply:function(t,e,n){return Function.prototype.apply.call(t,e,n)},Le;le&&typeof le.ownKeys=="function"?Le=le.ownKeys:Object.getOwnPropertySymbols?Le=function(t){return Object.getOwnPropertyNames(t).concat(Object.getOwnPropertySymbols(t))}:Le=function(t){return Object.getOwnPropertyNames(t)};function Ft(i){console&&console.warn&&console.warn(i)}var et=Number.isNaN||function(t){return t!==t};function A(){A.init.call(this)}Bt.exports=A;Se.once=Jt;A.EventEmitter=A;A.prototype._events=void 0;A.prototype._eventsCount=0;A.prototype._maxListeners=void 0;var Ve=10;function xe(i){if(typeof i!="function")throw new TypeError('The "listener" argument must be of type Function. Received type '+typeof i)}Object.defineProperty(A,"defaultMaxListeners",{enumerable:!0,get:function(){return Ve},set:function(i){if(typeof i!="number"||i<0||et(i))throw new RangeError('The value of "defaultMaxListeners" is out of range. It must be a non-negative number. Received '+i+".");Ve=i}});A.init=function(){(this._events===void 0||this._events===Object.getPrototypeOf(this)._events)&&(this._events=Object.create(null),this._eventsCount=0),this._maxListeners=this._maxListeners||void 0};A.prototype.setMaxListeners=function(t){if(typeof t!="number"||t<0||et(t))throw new RangeError('The value of "n" is out of range. It must be a non-negative number. Received '+t+".");return this._maxListeners=t,this};function tt(i){return i._maxListeners===void 0?A.defaultMaxListeners:i._maxListeners}A.prototype.getMaxListeners=function(){return tt(this)};A.prototype.emit=function(t){for(var e=[],n=1;n<arguments.length;n++)e.push(arguments[n]);var s=t==="error",o=this._events;if(o!==void 0)s=s&&o.error===void 0;else if(!s)return!1;if(s){var r;if(e.length>0&&(r=e[0]),r instanceof Error)throw r;var a=new Error("Unhandled error."+(r?" ("+r.message+")":""));throw a.context=r,a}var u=o[t];if(u===void 0)return!1;if(typeof u=="function")He(u,this,e);else for(var d=u.length,l=st(u,d),n=0;n<d;++n)He(l[n],this,e);return!0};function nt(i,t,e,n){var s,o,r;if(xe(e),o=i._events,o===void 0?(o=i._events=Object.create(null),i._eventsCount=0):(o.newListener!==void 0&&(i.emit("newListener",t,e.listener?e.listener:e),o=i._events),r=o[t]),r===void 0)r=o[t]=e,++i._eventsCount;else if(typeof r=="function"?r=o[t]=n?[e,r]:[r,e]:n?r.unshift(e):r.push(e),s=tt(i),s>0&&r.length>s&&!r.warned){r.warned=!0;var a=new Error("Possible EventEmitter memory leak detected. "+r.length+" "+String(t)+" listeners added. Use emitter.setMaxListeners() to increase limit");a.name="MaxListenersExceededWarning",a.emitter=i,a.type=t,a.count=r.length,Ft(a)}return i}A.prototype.addListener=function(t,e){return nt(this,t,e,!1)};A.prototype.on=A.prototype.addListener;A.prototype.prependListener=function(t,e){return nt(this,t,e,!0)};function Ht(){if(!this.fired)return this.target.removeListener(this.type,this.wrapFn),this.fired=!0,arguments.length===0?this.listener.call(this.target):this.listener.apply(this.target,arguments)}function it(i,t,e){var n={fired:!1,wrapFn:void 0,target:i,type:t,listener:e},s=Ht.bind(n);return s.listener=e,n.wrapFn=s,s}A.prototype.once=function(t,e){return xe(e),this.on(t,it(this,t,e)),this};A.prototype.prependOnceListener=function(t,e){return xe(e),this.prependListener(t,it(this,t,e)),this};A.prototype.removeListener=function(t,e){var n,s,o,r,a;if(xe(e),s=this._events,s===void 0)return this;if(n=s[t],n===void 0)return this;if(n===e||n.listener===e)--this._eventsCount===0?this._events=Object.create(null):(delete s[t],s.removeListener&&this.emit("removeListener",t,n.listener||e));else if(typeof n!="function"){for(o=-1,r=n.length-1;r>=0;r--)if(n[r]===e||n[r].listener===e){a=n[r].listener,o=r;break}if(o<0)return this;o===0?n.shift():Vt(n,o),n.length===1&&(s[t]=n[0]),s.removeListener!==void 0&&this.emit("removeListener",t,a||e)}return this};A.prototype.off=A.prototype.removeListener;A.prototype.removeAllListeners=function(t){var e,n,s;if(n=this._events,n===void 0)return this;if(n.removeListener===void 0)return arguments.length===0?(this._events=Object.create(null),this._eventsCount=0):n[t]!==void 0&&(--this._eventsCount===0?this._events=Object.create(null):delete n[t]),this;if(arguments.length===0){var o=Object.keys(n),r;for(s=0;s<o.length;++s)r=o[s],r!=="removeListener"&&this.removeAllListeners(r);return this.removeAllListeners("removeListener"),this._events=Object.create(null),this._eventsCount=0,this}if(e=n[t],typeof e=="function")this.removeListener(t,e);else if(e!==void 0)for(s=e.length-1;s>=0;s--)this.removeListener(t,e[s]);return this};function rt(i,t,e){var n=i._events;if(n===void 0)return[];var s=n[t];return s===void 0?[]:typeof s=="function"?e?[s.listener||s]:[s]:e?Yt(s):st(s,s.length)}A.prototype.listeners=function(t){return rt(this,t,!0)};A.prototype.rawListeners=function(t){return rt(this,t,!1)};A.listenerCount=function(i,t){return typeof i.listenerCount=="function"?i.listenerCount(t):ot.call(i,t)};A.prototype.listenerCount=ot;function ot(i){var t=this._events;if(t!==void 0){var e=t[i];if(typeof e=="function")return 1;if(e!==void 0)return e.length}return 0}A.prototype.eventNames=function(){return this._eventsCount>0?Le(this._events):[]};function st(i,t){for(var e=new Array(t),n=0;n<t;++n)e[n]=i[n];return e}function Vt(i,t){for(;t+1<i.length;t++)i[t]=i[t+1];i.pop()}function Yt(i){for(var t=new Array(i.length),e=0;e<t.length;++e)t[e]=i[e].listener||i[e];return t}function Jt(i,t){return new Promise(function(e,n){function s(r){i.removeListener(t,o),n(r)}function o(){typeof i.removeListener=="function"&&i.removeListener("error",s),e([].slice.call(arguments))}at(i,t,o,{once:!0}),t!=="error"&&qt(i,s,{once:!0})})}function qt(i,t,e){typeof i.on=="function"&&at(i,"error",t,e)}function at(i,t,e,n){if(typeof i.on=="function")n.once?i.once(t,e):i.on(t,e);else if(typeof i.addEventListener=="function")i.addEventListener(t,function s(o){n.once&&i.removeEventListener(t,s),e(o)});else throw new TypeError('The "emitter" argument must be of type EventEmitter. Received type '+typeof i)}function Q(i){if(typeof i!="function")throw new Error("obliterator/iterator: expecting a function!");this.next=i}typeof Symbol<"u"&&(Q.prototype[Symbol.iterator]=function(){return this});Q.of=function(){var i=arguments,t=i.length,e=0;return new Q(function(){return e>=t?{done:!0}:{done:!1,value:i[e++]}})};Q.empty=function(){var i=new Q(function(){return{done:!0}});return i};Q.fromSequence=function(i){var t=0,e=i.length;return new Q(function(){return t>=e?{done:!0}:{done:!1,value:i[t++]}})};Q.is=function(i){return i instanceof Q?!0:typeof i=="object"&&i!==null&&typeof i.next=="function"};var K=Q,Pe={};Pe.ARRAY_BUFFER_SUPPORT=typeof ArrayBuffer<"u";Pe.SYMBOL_SUPPORT=typeof Symbol<"u";var Zt=K,ut=Pe,Qt=ut.ARRAY_BUFFER_SUPPORT,Xt=ut.SYMBOL_SUPPORT;function Mt(i){return typeof i=="string"||Array.isArray(i)||Qt&&ArrayBuffer.isView(i)?Zt.fromSequence(i):typeof i!="object"||i===null?null:Xt&&typeof i[Symbol.iterator]=="function"?i[Symbol.iterator]():typeof i.next=="function"?i:null}var dt=function(t){var e=Mt(t);if(!e)throw new Error("obliterator: target is not iterable nor a valid iterator.");return e},en=dt,ht=function(t,e){for(var n=arguments.length>1?e:1/0,s=n!==1/0?new Array(n):[],o,r=0,a=en(t);;){if(r===n)return s;if(o=a.next(),o.done)return r!==e&&(s.length=r),s;s[r++]=o.value}},tn=K,nn=dt,te=function(){var t=arguments,e=null,n=-1;return new tn(function(){var o=null;do{if(e===null){if(n++,n>=t.length)return{done:!0};e=nn(t[n])}if(o=e.next(),o.done===!0){e=null;continue}break}while(!0);return o})};function rn(){const i=arguments[0];for(let t=1,e=arguments.length;t<e;t++)if(arguments[t])for(const n in arguments[t])i[n]=arguments[t][n];return i}let R=rn;typeof Object.assign=="function"&&(R=Object.assign);function V(i,t,e,n){const s=i._nodes.get(t);let o=null;return s&&(n==="mixed"?o=s.out&&s.out[e]||s.undirected&&s.undirected[e]:n==="directed"?o=s.out&&s.out[e]:o=s.undirected&&s.undirected[e]),o}function T(i){return typeof i=="object"&&i!==null}function ct(i){let t;for(t in i)return!1;return!0}function F(i,t,e){Object.defineProperty(i,t,{enumerable:!1,configurable:!1,writable:!0,value:e})}function Y(i,t,e){const n={enumerable:!0,configurable:!0};typeof e=="function"?n.get=e:(n.value=e,n.writable=!1),Object.defineProperty(i,t,n)}function Ye(i){return!(!T(i)||i.attributes&&!Array.isArray(i.attributes))}function on(){let i=Math.floor(Math.random()*256)&255;return()=>i++}class ze extends Error{constructor(t){super(),this.name="GraphError",this.message=t}}class g extends ze{constructor(t){super(t),this.name="InvalidArgumentsGraphError",typeof Error.captureStackTrace=="function"&&Error.captureStackTrace(this,g.prototype.constructor)}}class p extends ze{constructor(t){super(t),this.name="NotFoundGraphError",typeof Error.captureStackTrace=="function"&&Error.captureStackTrace(this,p.prototype.constructor)}}class w extends ze{constructor(t){super(t),this.name="UsageGraphError",typeof Error.captureStackTrace=="function"&&Error.captureStackTrace(this,w.prototype.constructor)}}function ft(i,t){this.key=i,this.attributes=t,this.clear()}ft.prototype.clear=function(){this.inDegree=0,this.outDegree=0,this.undirectedDegree=0,this.undirectedLoops=0,this.directedLoops=0,this.in={},this.out={},this.undirected={}};function lt(i,t){this.key=i,this.attributes=t,this.clear()}lt.prototype.clear=function(){this.inDegree=0,this.outDegree=0,this.directedLoops=0,this.in={},this.out={}};function pt(i,t){this.key=i,this.attributes=t,this.clear()}pt.prototype.clear=function(){this.undirectedDegree=0,this.undirectedLoops=0,this.undirected={}};function pe(i,t,e,n,s){this.key=t,this.attributes=s,this.undirected=i,this.source=e,this.target=n}pe.prototype.attach=function(){let i="out",t="in";this.undirected&&(i=t="undirected");const e=this.source.key,n=this.target.key;this.source[i][n]=this,!(this.undirected&&e===n)&&(this.target[t][e]=this)};pe.prototype.attachMulti=function(){let i="out",t="in";const e=this.source.key,n=this.target.key;this.undirected&&(i=t="undirected");const s=this.source[i],o=s[n];if(typeof o>"u"){s[n]=this,this.undirected&&e===n||(this.target[t][e]=this);return}o.previous=this,this.next=o,s[n]=this,this.target[t][e]=this};pe.prototype.detach=function(){const i=this.source.key,t=this.target.key;let e="out",n="in";this.undirected&&(e=n="undirected"),delete this.source[e][t],delete this.target[n][i]};pe.prototype.detachMulti=function(){const i=this.source.key,t=this.target.key;let e="out",n="in";this.undirected&&(e=n="undirected"),this.previous===void 0?this.next===void 0?(delete this.source[e][t],delete this.target[n][i]):(this.next.previous=void 0,this.source[e][t]=this.next,this.target[n][i]=this.next):(this.previous.next=this.next,this.next!==void 0&&(this.next.previous=this.previous))};const gt=0,yt=1,sn=2,wt=3;function ne(i,t,e,n,s,o,r){let a,u,d,l;if(n=""+n,e===gt){if(a=i._nodes.get(n),!a)throw new p(`Graph.${t}: could not find the "${n}" node in the graph.`);d=s,l=o}else if(e===wt){if(s=""+s,u=i._edges.get(s),!u)throw new p(`Graph.${t}: could not find the "${s}" edge in the graph.`);const c=u.source.key,h=u.target.key;if(n===c)a=u.target;else if(n===h)a=u.source;else throw new p(`Graph.${t}: the "${n}" node is not attached to the "${s}" edge (${c}, ${h}).`);d=o,l=r}else{if(u=i._edges.get(n),!u)throw new p(`Graph.${t}: could not find the "${n}" edge in the graph.`);e===yt?a=u.source:a=u.target,d=s,l=o}return[a,d,l]}function an(i,t,e){i.prototype[t]=function(n,s,o){const[r,a]=ne(this,t,e,n,s,o);return r.attributes[a]}}function un(i,t,e){i.prototype[t]=function(n,s){const[o]=ne(this,t,e,n,s);return o.attributes}}function dn(i,t,e){i.prototype[t]=function(n,s,o){const[r,a]=ne(this,t,e,n,s,o);return r.attributes.hasOwnProperty(a)}}function hn(i,t,e){i.prototype[t]=function(n,s,o,r){const[a,u,d]=ne(this,t,e,n,s,o,r);return a.attributes[u]=d,this.emit("nodeAttributesUpdated",{key:a.key,type:"set",attributes:a.attributes,name:u}),this}}function cn(i,t,e){i.prototype[t]=function(n,s,o,r){const[a,u,d]=ne(this,t,e,n,s,o,r);if(typeof d!="function")throw new g(`Graph.${t}: updater should be a function.`);const l=a.attributes,c=d(l[u]);return l[u]=c,this.emit("nodeAttributesUpdated",{key:a.key,type:"set",attributes:a.attributes,name:u}),this}}function fn(i,t,e){i.prototype[t]=function(n,s,o){const[r,a]=ne(this,t,e,n,s,o);return delete r.attributes[a],this.emit("nodeAttributesUpdated",{key:r.key,type:"remove",attributes:r.attributes,name:a}),this}}function ln(i,t,e){i.prototype[t]=function(n,s,o){const[r,a]=ne(this,t,e,n,s,o);if(!T(a))throw new g(`Graph.${t}: provided attributes are not a plain object.`);return r.attributes=a,this.emit("nodeAttributesUpdated",{key:r.key,type:"replace",attributes:r.attributes}),this}}function pn(i,t,e){i.prototype[t]=function(n,s,o){const[r,a]=ne(this,t,e,n,s,o);if(!T(a))throw new g(`Graph.${t}: provided attributes are not a plain object.`);return R(r.attributes,a),this.emit("nodeAttributesUpdated",{key:r.key,type:"merge",attributes:r.attributes,data:a}),this}}function gn(i,t,e){i.prototype[t]=function(n,s,o){const[r,a]=ne(this,t,e,n,s,o);if(typeof a!="function")throw new g(`Graph.${t}: provided updater is not a function.`);return r.attributes=a(r.attributes),this.emit("nodeAttributesUpdated",{key:r.key,type:"update",attributes:r.attributes}),this}}const yn=[{name:i=>`get${i}Attribute`,attacher:an},{name:i=>`get${i}Attributes`,attacher:un},{name:i=>`has${i}Attribute`,attacher:dn},{name:i=>`set${i}Attribute`,attacher:hn},{name:i=>`update${i}Attribute`,attacher:cn},{name:i=>`remove${i}Attribute`,attacher:fn},{name:i=>`replace${i}Attributes`,attacher:ln},{name:i=>`merge${i}Attributes`,attacher:pn},{name:i=>`update${i}Attributes`,attacher:gn}];function wn(i){yn.forEach(function({name:t,attacher:e}){e(i,t("Node"),gt),e(i,t("Source"),yt),e(i,t("Target"),sn),e(i,t("Opposite"),wt)})}function mn(i,t,e){i.prototype[t]=function(n,s){let o;if(this.type!=="mixed"&&e!=="mixed"&&e!==this.type)throw new w(`Graph.${t}: cannot find this type of edges in your ${this.type} graph.`);if(arguments.length>2){if(this.multi)throw new w(`Graph.${t}: cannot use a {source,target} combo when asking about an edge's attributes in a MultiGraph since we cannot infer the one you want information about.`);const r=""+n,a=""+s;if(s=arguments[2],o=V(this,r,a,e),!o)throw new p(`Graph.${t}: could not find an edge for the given path ("${r}" - "${a}").`)}else{if(e!=="mixed")throw new w(`Graph.${t}: calling this method with only a key (vs. a source and target) does not make sense since an edge with this key could have the other type.`);if(n=""+n,o=this._edges.get(n),!o)throw new p(`Graph.${t}: could not find the "${n}" edge in the graph.`)}return o.attributes[s]}}function bn(i,t,e){i.prototype[t]=function(n){let s;if(this.type!=="mixed"&&e!=="mixed"&&e!==this.type)throw new w(`Graph.${t}: cannot find this type of edges in your ${this.type} graph.`);if(arguments.length>1){if(this.multi)throw new w(`Graph.${t}: cannot use a {source,target} combo when asking about an edge's attributes in a MultiGraph since we cannot infer the one you want information about.`);const o=""+n,r=""+arguments[1];if(s=V(this,o,r,e),!s)throw new p(`Graph.${t}: could not find an edge for the given path ("${o}" - "${r}").`)}else{if(e!=="mixed")throw new w(`Graph.${t}: calling this method with only a key (vs. a source and target) does not make sense since an edge with this key could have the other type.`);if(n=""+n,s=this._edges.get(n),!s)throw new p(`Graph.${t}: could not find the "${n}" edge in the graph.`)}return s.attributes}}function vn(i,t,e){i.prototype[t]=function(n,s){let o;if(this.type!=="mixed"&&e!=="mixed"&&e!==this.type)throw new w(`Graph.${t}: cannot find this type of edges in your ${this.type} graph.`);if(arguments.length>2){if(this.multi)throw new w(`Graph.${t}: cannot use a {source,target} combo when asking about an edge's attributes in a MultiGraph since we cannot infer the one you want information about.`);const r=""+n,a=""+s;if(s=arguments[2],o=V(this,r,a,e),!o)throw new p(`Graph.${t}: could not find an edge for the given path ("${r}" - "${a}").`)}else{if(e!=="mixed")throw new w(`Graph.${t}: calling this method with only a key (vs. a source and target) does not make sense since an edge with this key could have the other type.`);if(n=""+n,o=this._edges.get(n),!o)throw new p(`Graph.${t}: could not find the "${n}" edge in the graph.`)}return o.attributes.hasOwnProperty(s)}}function En(i,t,e){i.prototype[t]=function(n,s,o){let r;if(this.type!=="mixed"&&e!=="mixed"&&e!==this.type)throw new w(`Graph.${t}: cannot find this type of edges in your ${this.type} graph.`);if(arguments.length>3){if(this.multi)throw new w(`Graph.${t}: cannot use a {source,target} combo when asking about an edge's attributes in a MultiGraph since we cannot infer the one you want information about.`);const a=""+n,u=""+s;if(s=arguments[2],o=arguments[3],r=V(this,a,u,e),!r)throw new p(`Graph.${t}: could not find an edge for the given path ("${a}" - "${u}").`)}else{if(e!=="mixed")throw new w(`Graph.${t}: calling this method with only a key (vs. a source and target) does not make sense since an edge with this key could have the other type.`);if(n=""+n,r=this._edges.get(n),!r)throw new p(`Graph.${t}: could not find the "${n}" edge in the graph.`)}return r.attributes[s]=o,this.emit("edgeAttributesUpdated",{key:r.key,type:"set",attributes:r.attributes,name:s}),this}}function _n(i,t,e){i.prototype[t]=function(n,s,o){let r;if(this.type!=="mixed"&&e!=="mixed"&&e!==this.type)throw new w(`Graph.${t}: cannot find this type of edges in your ${this.type} graph.`);if(arguments.length>3){if(this.multi)throw new w(`Graph.${t}: cannot use a {source,target} combo when asking about an edge's attributes in a MultiGraph since we cannot infer the one you want information about.`);const a=""+n,u=""+s;if(s=arguments[2],o=arguments[3],r=V(this,a,u,e),!r)throw new p(`Graph.${t}: could not find an edge for the given path ("${a}" - "${u}").`)}else{if(e!=="mixed")throw new w(`Graph.${t}: calling this method with only a key (vs. a source and target) does not make sense since an edge with this key could have the other type.`);if(n=""+n,r=this._edges.get(n),!r)throw new p(`Graph.${t}: could not find the "${n}" edge in the graph.`)}if(typeof o!="function")throw new g(`Graph.${t}: updater should be a function.`);return r.attributes[s]=o(r.attributes[s]),this.emit("edgeAttributesUpdated",{key:r.key,type:"set",attributes:r.attributes,name:s}),this}}function $n(i,t,e){i.prototype[t]=function(n,s){let o;if(this.type!=="mixed"&&e!=="mixed"&&e!==this.type)throw new w(`Graph.${t}: cannot find this type of edges in your ${this.type} graph.`);if(arguments.length>2){if(this.multi)throw new w(`Graph.${t}: cannot use a {source,target} combo when asking about an edge's attributes in a MultiGraph since we cannot infer the one you want information about.`);const r=""+n,a=""+s;if(s=arguments[2],o=V(this,r,a,e),!o)throw new p(`Graph.${t}: could not find an edge for the given path ("${r}" - "${a}").`)}else{if(e!=="mixed")throw new w(`Graph.${t}: calling this method with only a key (vs. a source and target) does not make sense since an edge with this key could have the other type.`);if(n=""+n,o=this._edges.get(n),!o)throw new p(`Graph.${t}: could not find the "${n}" edge in the graph.`)}return delete o.attributes[s],this.emit("edgeAttributesUpdated",{key:o.key,type:"remove",attributes:o.attributes,name:s}),this}}function Gn(i,t,e){i.prototype[t]=function(n,s){let o;if(this.type!=="mixed"&&e!=="mixed"&&e!==this.type)throw new w(`Graph.${t}: cannot find this type of edges in your ${this.type} graph.`);if(arguments.length>2){if(this.multi)throw new w(`Graph.${t}: cannot use a {source,target} combo when asking about an edge's attributes in a MultiGraph since we cannot infer the one you want information about.`);const r=""+n,a=""+s;if(s=arguments[2],o=V(this,r,a,e),!o)throw new p(`Graph.${t}: could not find an edge for the given path ("${r}" - "${a}").`)}else{if(e!=="mixed")throw new w(`Graph.${t}: calling this method with only a key (vs. a source and target) does not make sense since an edge with this key could have the other type.`);if(n=""+n,o=this._edges.get(n),!o)throw new p(`Graph.${t}: could not find the "${n}" edge in the graph.`)}if(!T(s))throw new g(`Graph.${t}: provided attributes are not a plain object.`);return o.attributes=s,this.emit("edgeAttributesUpdated",{key:o.key,type:"replace",attributes:o.attributes}),this}}function kn(i,t,e){i.prototype[t]=function(n,s){let o;if(this.type!=="mixed"&&e!=="mixed"&&e!==this.type)throw new w(`Graph.${t}: cannot find this type of edges in your ${this.type} graph.`);if(arguments.length>2){if(this.multi)throw new w(`Graph.${t}: cannot use a {source,target} combo when asking about an edge's attributes in a MultiGraph since we cannot infer the one you want information about.`);const r=""+n,a=""+s;if(s=arguments[2],o=V(this,r,a,e),!o)throw new p(`Graph.${t}: could not find an edge for the given path ("${r}" - "${a}").`)}else{if(e!=="mixed")throw new w(`Graph.${t}: calling this method with only a key (vs. a source and target) does not make sense since an edge with this key could have the other type.`);if(n=""+n,o=this._edges.get(n),!o)throw new p(`Graph.${t}: could not find the "${n}" edge in the graph.`)}if(!T(s))throw new g(`Graph.${t}: provided attributes are not a plain object.`);return R(o.attributes,s),this.emit("edgeAttributesUpdated",{key:o.key,type:"merge",attributes:o.attributes,data:s}),this}}function Dn(i,t,e){i.prototype[t]=function(n,s){let o;if(this.type!=="mixed"&&e!=="mixed"&&e!==this.type)throw new w(`Graph.${t}: cannot find this type of edges in your ${this.type} graph.`);if(arguments.length>2){if(this.multi)throw new w(`Graph.${t}: cannot use a {source,target} combo when asking about an edge's attributes in a MultiGraph since we cannot infer the one you want information about.`);const r=""+n,a=""+s;if(s=arguments[2],o=V(this,r,a,e),!o)throw new p(`Graph.${t}: could not find an edge for the given path ("${r}" - "${a}").`)}else{if(e!=="mixed")throw new w(`Graph.${t}: calling this method with only a key (vs. a source and target) does not make sense since an edge with this key could have the other type.`);if(n=""+n,o=this._edges.get(n),!o)throw new p(`Graph.${t}: could not find the "${n}" edge in the graph.`)}if(typeof s!="function")throw new g(`Graph.${t}: provided updater is not a function.`);return o.attributes=s(o.attributes),this.emit("edgeAttributesUpdated",{key:o.key,type:"update",attributes:o.attributes}),this}}const An=[{name:i=>`get${i}Attribute`,attacher:mn},{name:i=>`get${i}Attributes`,attacher:bn},{name:i=>`has${i}Attribute`,attacher:vn},{name:i=>`set${i}Attribute`,attacher:En},{name:i=>`update${i}Attribute`,attacher:_n},{name:i=>`remove${i}Attribute`,attacher:$n},{name:i=>`replace${i}Attributes`,attacher:Gn},{name:i=>`merge${i}Attributes`,attacher:kn},{name:i=>`update${i}Attributes`,attacher:Dn}];function Nn(i){An.forEach(function({name:t,attacher:e}){e(i,t("Edge"),"mixed"),e(i,t("DirectedEdge"),"directed"),e(i,t("UndirectedEdge"),"undirected")})}const Ln=[{name:"edges",type:"mixed"},{name:"inEdges",type:"directed",direction:"in"},{name:"outEdges",type:"directed",direction:"out"},{name:"inboundEdges",type:"mixed",direction:"in"},{name:"outboundEdges",type:"mixed",direction:"out"},{name:"directedEdges",type:"directed"},{name:"undirectedEdges",type:"undirected"}];function Sn(i,t,e,n){let s=!1;for(const o in t){if(o===n)continue;const r=t[o];if(s=e(r.key,r.attributes,r.source.key,r.target.key,r.source.attributes,r.target.attributes,r.undirected),i&&s)return r.key}}function xn(i,t,e,n){let s,o,r,a=!1;for(const u in t)if(u!==n){s=t[u];do{if(o=s.source,r=s.target,a=e(s.key,s.attributes,o.key,r.key,o.attributes,r.attributes,s.undirected),i&&a)return s.key;s=s.next}while(s!==void 0)}}function Re(i,t){const e=Object.keys(i),n=e.length;let s,o=0;return new K(function(){do if(s)s=s.next;else{if(o>=n)return{done:!0};const a=e[o++];if(a===t){s=void 0;continue}s=i[a]}while(!s);return{done:!1,value:{edge:s.key,attributes:s.attributes,source:s.source.key,target:s.target.key,sourceAttributes:s.source.attributes,targetAttributes:s.target.attributes,undirected:s.undirected}}})}function Un(i,t,e,n){const s=t[e];if(!s)return;const o=s.source,r=s.target;if(n(s.key,s.attributes,o.key,r.key,o.attributes,r.attributes,s.undirected)&&i)return s.key}function On(i,t,e,n){let s=t[e];if(!s)return;let o=!1;do{if(o=n(s.key,s.attributes,s.source.key,s.target.key,s.source.attributes,s.target.attributes,s.undirected),i&&o)return s.key;s=s.next}while(s!==void 0)}function Ce(i,t){let e=i[t];return e.next!==void 0?new K(function(){if(!e)return{done:!0};const n={edge:e.key,attributes:e.attributes,source:e.source.key,target:e.target.key,sourceAttributes:e.source.attributes,targetAttributes:e.target.attributes,undirected:e.undirected};return e=e.next,{done:!1,value:n}}):K.of({edge:e.key,attributes:e.attributes,source:e.source.key,target:e.target.key,sourceAttributes:e.source.attributes,targetAttributes:e.target.attributes,undirected:e.undirected})}function In(i,t){if(i.size===0)return[];if(t==="mixed"||t===i.type)return typeof Array.from=="function"?Array.from(i._edges.keys()):ht(i._edges.keys(),i._edges.size);const e=t==="undirected"?i.undirectedSize:i.directedSize,n=new Array(e),s=t==="undirected",o=i._edges.values();let r=0,a,u;for(;a=o.next(),a.done!==!0;)u=a.value,u.undirected===s&&(n[r++]=u.key);return n}function mt(i,t,e,n){if(t.size===0)return;const s=e!=="mixed"&&e!==t.type,o=e==="undirected";let r,a,u=!1;const d=t._edges.values();for(;r=d.next(),r.done!==!0;){if(a=r.value,s&&a.undirected!==o)continue;const{key:l,attributes:c,source:h,target:y}=a;if(u=n(l,c,h.key,y.key,h.attributes,y.attributes,a.undirected),i&&u)return l}}function Rn(i,t){if(i.size===0)return K.empty();const e=t!=="mixed"&&t!==i.type,n=t==="undirected",s=i._edges.values();return new K(function(){let r,a;for(;;){if(r=s.next(),r.done)return r;if(a=r.value,!(e&&a.undirected!==n))break}return{value:{edge:a.key,attributes:a.attributes,source:a.source.key,target:a.target.key,sourceAttributes:a.source.attributes,targetAttributes:a.target.attributes,undirected:a.undirected},done:!1}})}function We(i,t,e,n,s,o){const r=t?xn:Sn;let a;if(e!=="undirected"&&(n!=="out"&&(a=r(i,s.in,o),i&&a)||n!=="in"&&(a=r(i,s.out,o,n?void 0:s.key),i&&a))||e!=="directed"&&(a=r(i,s.undirected,o),i&&a))return a}function Cn(i,t,e,n){const s=[];return We(!1,i,t,e,n,function(o){s.push(o)}),s}function Tn(i,t,e){let n=K.empty();return i!=="undirected"&&(t!=="out"&&typeof e.in<"u"&&(n=te(n,Re(e.in))),t!=="in"&&typeof e.out<"u"&&(n=te(n,Re(e.out,t?void 0:e.key)))),i!=="directed"&&typeof e.undirected<"u"&&(n=te(n,Re(e.undirected))),n}function Ke(i,t,e,n,s,o,r){const a=e?On:Un;let u;if(t!=="undirected"&&(typeof s.in<"u"&&n!=="out"&&(u=a(i,s.in,o,r),i&&u)||typeof s.out<"u"&&n!=="in"&&(n||s.key!==o)&&(u=a(i,s.out,o,r),i&&u))||t!=="directed"&&typeof s.undirected<"u"&&(u=a(i,s.undirected,o,r),i&&u))return u}function jn(i,t,e,n,s){const o=[];return Ke(!1,i,t,e,n,s,function(r){o.push(r)}),o}function Pn(i,t,e,n){let s=K.empty();return i!=="undirected"&&(typeof e.in<"u"&&t!=="out"&&n in e.in&&(s=te(s,Ce(e.in,n))),typeof e.out<"u"&&t!=="in"&&n in e.out&&(t||e.key!==n)&&(s=te(s,Ce(e.out,n)))),i!=="directed"&&typeof e.undirected<"u"&&n in e.undirected&&(s=te(s,Ce(e.undirected,n))),s}function zn(i,t){const{name:e,type:n,direction:s}=t;i.prototype[e]=function(o,r){if(n!=="mixed"&&this.type!=="mixed"&&n!==this.type)return[];if(!arguments.length)return In(this,n);if(arguments.length===1){o=""+o;const a=this._nodes.get(o);if(typeof a>"u")throw new p(`Graph.${e}: could not find the "${o}" node in the graph.`);return Cn(this.multi,n==="mixed"?this.type:n,s,a)}if(arguments.length===2){o=""+o,r=""+r;const a=this._nodes.get(o);if(!a)throw new p(`Graph.${e}:  could not find the "${o}" source node in the graph.`);if(!this._nodes.has(r))throw new p(`Graph.${e}:  could not find the "${r}" target node in the graph.`);return jn(n,this.multi,s,a,r)}throw new g(`Graph.${e}: too many arguments (expecting 0, 1 or 2 and got ${arguments.length}).`)}}function Wn(i,t){const{name:e,type:n,direction:s}=t,o="forEach"+e[0].toUpperCase()+e.slice(1,-1);i.prototype[o]=function(d,l,c){if(!(n!=="mixed"&&this.type!=="mixed"&&n!==this.type)){if(arguments.length===1)return c=d,mt(!1,this,n,c);if(arguments.length===2){d=""+d,c=l;const h=this._nodes.get(d);if(typeof h>"u")throw new p(`Graph.${o}: could not find the "${d}" node in the graph.`);return We(!1,this.multi,n==="mixed"?this.type:n,s,h,c)}if(arguments.length===3){d=""+d,l=""+l;const h=this._nodes.get(d);if(!h)throw new p(`Graph.${o}:  could not find the "${d}" source node in the graph.`);if(!this._nodes.has(l))throw new p(`Graph.${o}:  could not find the "${l}" target node in the graph.`);return Ke(!1,n,this.multi,s,h,l,c)}throw new g(`Graph.${o}: too many arguments (expecting 1, 2 or 3 and got ${arguments.length}).`)}};const r="map"+e[0].toUpperCase()+e.slice(1);i.prototype[r]=function(){const d=Array.prototype.slice.call(arguments),l=d.pop();let c;if(d.length===0){let h=0;n!=="directed"&&(h+=this.undirectedSize),n!=="undirected"&&(h+=this.directedSize),c=new Array(h);let y=0;d.push((v,L,S,O,P,D,E)=>{c[y++]=l(v,L,S,O,P,D,E)})}else c=[],d.push((h,y,v,L,S,O,P)=>{c.push(l(h,y,v,L,S,O,P))});return this[o].apply(this,d),c};const a="filter"+e[0].toUpperCase()+e.slice(1);i.prototype[a]=function(){const d=Array.prototype.slice.call(arguments),l=d.pop(),c=[];return d.push((h,y,v,L,S,O,P)=>{l(h,y,v,L,S,O,P)&&c.push(h)}),this[o].apply(this,d),c};const u="reduce"+e[0].toUpperCase()+e.slice(1);i.prototype[u]=function(){let d=Array.prototype.slice.call(arguments);if(d.length<2||d.length>4)throw new g(`Graph.${u}: invalid number of arguments (expecting 2, 3 or 4 and got ${d.length}).`);if(typeof d[d.length-1]=="function"&&typeof d[d.length-2]!="function")throw new g(`Graph.${u}: missing initial value. You must provide it because the callback takes more than one argument and we cannot infer the initial value from the first iteration, as you could with a simple array.`);let l,c;d.length===2?(l=d[0],c=d[1],d=[]):d.length===3?(l=d[1],c=d[2],d=[d[0]]):d.length===4&&(l=d[2],c=d[3],d=[d[0],d[1]]);let h=c;return d.push((y,v,L,S,O,P,D)=>{h=l(h,y,v,L,S,O,P,D)}),this[o].apply(this,d),h}}function Kn(i,t){const{name:e,type:n,direction:s}=t,o="find"+e[0].toUpperCase()+e.slice(1,-1);i.prototype[o]=function(u,d,l){if(n!=="mixed"&&this.type!=="mixed"&&n!==this.type)return!1;if(arguments.length===1)return l=u,mt(!0,this,n,l);if(arguments.length===2){u=""+u,l=d;const c=this._nodes.get(u);if(typeof c>"u")throw new p(`Graph.${o}: could not find the "${u}" node in the graph.`);return We(!0,this.multi,n==="mixed"?this.type:n,s,c,l)}if(arguments.length===3){u=""+u,d=""+d;const c=this._nodes.get(u);if(!c)throw new p(`Graph.${o}:  could not find the "${u}" source node in the graph.`);if(!this._nodes.has(d))throw new p(`Graph.${o}:  could not find the "${d}" target node in the graph.`);return Ke(!0,n,this.multi,s,c,d,l)}throw new g(`Graph.${o}: too many arguments (expecting 1, 2 or 3 and got ${arguments.length}).`)};const r="some"+e[0].toUpperCase()+e.slice(1,-1);i.prototype[r]=function(){const u=Array.prototype.slice.call(arguments),d=u.pop();return u.push((c,h,y,v,L,S,O)=>d(c,h,y,v,L,S,O)),!!this[o].apply(this,u)};const a="every"+e[0].toUpperCase()+e.slice(1,-1);i.prototype[a]=function(){const u=Array.prototype.slice.call(arguments),d=u.pop();return u.push((c,h,y,v,L,S,O)=>!d(c,h,y,v,L,S,O)),!this[o].apply(this,u)}}function Bn(i,t){const{name:e,type:n,direction:s}=t,o=e.slice(0,-1)+"Entries";i.prototype[o]=function(r,a){if(n!=="mixed"&&this.type!=="mixed"&&n!==this.type)return K.empty();if(!arguments.length)return Rn(this,n);if(arguments.length===1){r=""+r;const u=this._nodes.get(r);if(!u)throw new p(`Graph.${o}: could not find the "${r}" node in the graph.`);return Tn(n,s,u)}if(arguments.length===2){r=""+r,a=""+a;const u=this._nodes.get(r);if(!u)throw new p(`Graph.${o}:  could not find the "${r}" source node in the graph.`);if(!this._nodes.has(a))throw new p(`Graph.${o}:  could not find the "${a}" target node in the graph.`);return Pn(n,s,u,a)}throw new g(`Graph.${o}: too many arguments (expecting 0, 1 or 2 and got ${arguments.length}).`)}}function Fn(i){Ln.forEach(t=>{zn(i,t),Wn(i,t),Kn(i,t),Bn(i,t)})}const Hn=[{name:"neighbors",type:"mixed"},{name:"inNeighbors",type:"directed",direction:"in"},{name:"outNeighbors",type:"directed",direction:"out"},{name:"inboundNeighbors",type:"mixed",direction:"in"},{name:"outboundNeighbors",type:"mixed",direction:"out"},{name:"directedNeighbors",type:"directed"},{name:"undirectedNeighbors",type:"undirected"}];function Ue(){this.A=null,this.B=null}Ue.prototype.wrap=function(i){this.A===null?this.A=i:this.B===null&&(this.B=i)};Ue.prototype.has=function(i){return this.A!==null&&i in this.A||this.B!==null&&i in this.B};function we(i,t,e,n,s){for(const o in n){const r=n[o],a=r.source,u=r.target,d=a===e?u:a;if(t&&t.has(d.key))continue;const l=s(d.key,d.attributes);if(i&&l)return d.key}}function Be(i,t,e,n,s){if(t!=="mixed"){if(t==="undirected")return we(i,null,n,n.undirected,s);if(typeof e=="string")return we(i,null,n,n[e],s)}const o=new Ue;let r;if(t!=="undirected"){if(e!=="out"){if(r=we(i,null,n,n.in,s),i&&r)return r;o.wrap(n.in)}if(e!=="in"){if(r=we(i,o,n,n.out,s),i&&r)return r;o.wrap(n.out)}}if(t!=="directed"&&(r=we(i,o,n,n.undirected,s),i&&r))return r}function Vn(i,t,e){if(i!=="mixed"){if(i==="undirected")return Object.keys(e.undirected);if(typeof t=="string")return Object.keys(e[t])}const n=[];return Be(!1,i,t,e,function(s){n.push(s)}),n}function me(i,t,e){const n=Object.keys(e),s=n.length;let o=0;return new K(function(){let a=null;do{if(o>=s)return i&&i.wrap(e),{done:!0};const u=e[n[o++]],d=u.source,l=u.target;if(a=d===t?l:d,i&&i.has(a.key)){a=null;continue}}while(a===null);return{done:!1,value:{neighbor:a.key,attributes:a.attributes}}})}function Yn(i,t,e){if(i!=="mixed"){if(i==="undirected")return me(null,e,e.undirected);if(typeof t=="string")return me(null,e,e[t])}let n=K.empty();const s=new Ue;return i!=="undirected"&&(t!=="out"&&(n=te(n,me(s,e,e.in))),t!=="in"&&(n=te(n,me(s,e,e.out)))),i!=="directed"&&(n=te(n,me(s,e,e.undirected))),n}function Jn(i,t){const{name:e,type:n,direction:s}=t;i.prototype[e]=function(o){if(n!=="mixed"&&this.type!=="mixed"&&n!==this.type)return[];o=""+o;const r=this._nodes.get(o);if(typeof r>"u")throw new p(`Graph.${e}: could not find the "${o}" node in the graph.`);return Vn(n==="mixed"?this.type:n,s,r)}}function qn(i,t){const{name:e,type:n,direction:s}=t,o="forEach"+e[0].toUpperCase()+e.slice(1,-1);i.prototype[o]=function(d,l){if(n!=="mixed"&&this.type!=="mixed"&&n!==this.type)return;d=""+d;const c=this._nodes.get(d);if(typeof c>"u")throw new p(`Graph.${o}: could not find the "${d}" node in the graph.`);Be(!1,n==="mixed"?this.type:n,s,c,l)};const r="map"+e[0].toUpperCase()+e.slice(1);i.prototype[r]=function(d,l){const c=[];return this[o](d,(h,y)=>{c.push(l(h,y))}),c};const a="filter"+e[0].toUpperCase()+e.slice(1);i.prototype[a]=function(d,l){const c=[];return this[o](d,(h,y)=>{l(h,y)&&c.push(h)}),c};const u="reduce"+e[0].toUpperCase()+e.slice(1);i.prototype[u]=function(d,l,c){if(arguments.length<3)throw new g(`Graph.${u}: missing initial value. You must provide it because the callback takes more than one argument and we cannot infer the initial value from the first iteration, as you could with a simple array.`);let h=c;return this[o](d,(y,v)=>{h=l(h,y,v)}),h}}function Zn(i,t){const{name:e,type:n,direction:s}=t,o=e[0].toUpperCase()+e.slice(1,-1),r="find"+o;i.prototype[r]=function(d,l){if(n!=="mixed"&&this.type!=="mixed"&&n!==this.type)return;d=""+d;const c=this._nodes.get(d);if(typeof c>"u")throw new p(`Graph.${r}: could not find the "${d}" node in the graph.`);return Be(!0,n==="mixed"?this.type:n,s,c,l)};const a="some"+o;i.prototype[a]=function(d,l){return!!this[r](d,l)};const u="every"+o;i.prototype[u]=function(d,l){return!this[r](d,(h,y)=>!l(h,y))}}function Qn(i,t){const{name:e,type:n,direction:s}=t,o=e.slice(0,-1)+"Entries";i.prototype[o]=function(r){if(n!=="mixed"&&this.type!=="mixed"&&n!==this.type)return K.empty();r=""+r;const a=this._nodes.get(r);if(typeof a>"u")throw new p(`Graph.${o}: could not find the "${r}" node in the graph.`);return Yn(n==="mixed"?this.type:n,s,a)}}function Xn(i){Hn.forEach(t=>{Jn(i,t),qn(i,t),Zn(i,t),Qn(i,t)})}function Ae(i,t,e,n,s){const o=n._nodes.values(),r=n.type;let a,u,d,l,c,h,y;for(;a=o.next(),a.done!==!0;){let v=!1;if(u=a.value,r!=="undirected"){l=u.out;for(d in l){c=l[d];do{if(h=c.target,v=!0,y=s(u.key,h.key,u.attributes,h.attributes,c.key,c.attributes,c.undirected),i&&y)return c;c=c.next}while(c)}}if(r!=="directed"){l=u.undirected;for(d in l)if(!(t&&u.key>d)){c=l[d];do{if(h=c.target,h.key!==d&&(h=c.source),v=!0,y=s(u.key,h.key,u.attributes,h.attributes,c.key,c.attributes,c.undirected),i&&y)return c;c=c.next}while(c)}}if(e&&!v&&(y=s(u.key,null,u.attributes,null,null,null,null),i&&y))return null}}function Mn(i,t){const e={key:i};return ct(t.attributes)||(e.attributes=R({},t.attributes)),e}function ei(i,t,e){const n={key:t,source:e.source.key,target:e.target.key};return ct(e.attributes)||(n.attributes=R({},e.attributes)),i==="mixed"&&e.undirected&&(n.undirected=!0),n}function ti(i){if(!T(i))throw new g('Graph.import: invalid serialized node. A serialized node should be a plain object with at least a "key" property.');if(!("key"in i))throw new g("Graph.import: serialized node is missing its key.");if("attributes"in i&&(!T(i.attributes)||i.attributes===null))throw new g("Graph.import: invalid attributes. Attributes should be a plain object, null or omitted.")}function ni(i){if(!T(i))throw new g('Graph.import: invalid serialized edge. A serialized edge should be a plain object with at least a "source" & "target" property.');if(!("source"in i))throw new g("Graph.import: serialized edge is missing its source.");if(!("target"in i))throw new g("Graph.import: serialized edge is missing its target.");if("attributes"in i&&(!T(i.attributes)||i.attributes===null))throw new g("Graph.import: invalid attributes. Attributes should be a plain object, null or omitted.");if("undirected"in i&&typeof i.undirected!="boolean")throw new g("Graph.import: invalid undirectedness information. Undirected should be boolean or omitted.")}const ii=on(),ri=new Set(["directed","undirected","mixed"]),Je=new Set(["domain","_events","_eventsCount","_maxListeners"]),oi=[{name:i=>`${i}Edge`,generateKey:!0},{name:i=>`${i}DirectedEdge`,generateKey:!0,type:"directed"},{name:i=>`${i}UndirectedEdge`,generateKey:!0,type:"undirected"},{name:i=>`${i}EdgeWithKey`},{name:i=>`${i}DirectedEdgeWithKey`,type:"directed"},{name:i=>`${i}UndirectedEdgeWithKey`,type:"undirected"}],si={allowSelfLoops:!0,multi:!1,type:"mixed"};function ai(i,t,e){if(e&&!T(e))throw new g(`Graph.addNode: invalid attributes. Expecting an object but got "${e}"`);if(t=""+t,e=e||{},i._nodes.has(t))throw new w(`Graph.addNode: the "${t}" node already exist in the graph.`);const n=new i.NodeDataClass(t,e);return i._nodes.set(t,n),i.emit("nodeAdded",{key:t,attributes:e}),n}function qe(i,t,e){const n=new i.NodeDataClass(t,e);return i._nodes.set(t,n),i.emit("nodeAdded",{key:t,attributes:e}),n}function bt(i,t,e,n,s,o,r,a){if(!n&&i.type==="undirected")throw new w(`Graph.${t}: you cannot add a directed edge to an undirected graph. Use the #.addEdge or #.addUndirectedEdge instead.`);if(n&&i.type==="directed")throw new w(`Graph.${t}: you cannot add an undirected edge to a directed graph. Use the #.addEdge or #.addDirectedEdge instead.`);if(a&&!T(a))throw new g(`Graph.${t}: invalid attributes. Expecting an object but got "${a}"`);if(o=""+o,r=""+r,a=a||{},!i.allowSelfLoops&&o===r)throw new w(`Graph.${t}: source & target are the same ("${o}"), thus creating a loop explicitly forbidden by this graph 'allowSelfLoops' option set to false.`);const u=i._nodes.get(o),d=i._nodes.get(r);if(!u)throw new p(`Graph.${t}: source node "${o}" not found.`);if(!d)throw new p(`Graph.${t}: target node "${r}" not found.`);const l={key:null,undirected:n,source:o,target:r,attributes:a};if(e)s=i._edgeKeyGenerator();else if(s=""+s,i._edges.has(s))throw new w(`Graph.${t}: the "${s}" edge already exists in the graph.`);if(!i.multi&&(n?typeof u.undirected[r]<"u":typeof u.out[r]<"u"))throw new w(`Graph.${t}: an edge linking "${o}" to "${r}" already exists. If you really want to add multiple edges linking those nodes, you should create a multi graph by using the 'multi' option.`);const c=new pe(n,s,u,d,a);i._edges.set(s,c);const h=o===r;return n?(u.undirectedDegree++,d.undirectedDegree++,h&&(u.undirectedLoops++,i._undirectedSelfLoopCount++)):(u.outDegree++,d.inDegree++,h&&(u.directedLoops++,i._directedSelfLoopCount++)),i.multi?c.attachMulti():c.attach(),n?i._undirectedSize++:i._directedSize++,l.key=s,i.emit("edgeAdded",l),s}function ui(i,t,e,n,s,o,r,a,u){if(!n&&i.type==="undirected")throw new w(`Graph.${t}: you cannot merge/update a directed edge to an undirected graph. Use the #.mergeEdge/#.updateEdge or #.addUndirectedEdge instead.`);if(n&&i.type==="directed")throw new w(`Graph.${t}: you cannot merge/update an undirected edge to a directed graph. Use the #.mergeEdge/#.updateEdge or #.addDirectedEdge instead.`);if(a){if(u){if(typeof a!="function")throw new g(`Graph.${t}: invalid updater function. Expecting a function but got "${a}"`)}else if(!T(a))throw new g(`Graph.${t}: invalid attributes. Expecting an object but got "${a}"`)}o=""+o,r=""+r;let d;if(u&&(d=a,a=void 0),!i.allowSelfLoops&&o===r)throw new w(`Graph.${t}: source & target are the same ("${o}"), thus creating a loop explicitly forbidden by this graph 'allowSelfLoops' option set to false.`);let l=i._nodes.get(o),c=i._nodes.get(r),h,y;if(!e&&(h=i._edges.get(s),h)){if((h.source.key!==o||h.target.key!==r)&&(!n||h.source.key!==r||h.target.key!==o))throw new w(`Graph.${t}: inconsistency detected when attempting to merge the "${s}" edge with "${o}" source & "${r}" target vs. ("${h.source.key}", "${h.target.key}").`);y=h}if(!y&&!i.multi&&l&&(y=n?l.undirected[r]:l.out[r]),y){const P=[y.key,!1,!1,!1];if(u?!d:!a)return P;if(u){const D=y.attributes;y.attributes=d(D),i.emit("edgeAttributesUpdated",{type:"replace",key:y.key,attributes:y.attributes})}else R(y.attributes,a),i.emit("edgeAttributesUpdated",{type:"merge",key:y.key,attributes:y.attributes,data:a});return P}a=a||{},u&&d&&(a=d(a));const v={key:null,undirected:n,source:o,target:r,attributes:a};if(e)s=i._edgeKeyGenerator();else if(s=""+s,i._edges.has(s))throw new w(`Graph.${t}: the "${s}" edge already exists in the graph.`);let L=!1,S=!1;l||(l=qe(i,o,{}),L=!0,o===r&&(c=l,S=!0)),c||(c=qe(i,r,{}),S=!0),h=new pe(n,s,l,c,a),i._edges.set(s,h);const O=o===r;return n?(l.undirectedDegree++,c.undirectedDegree++,O&&(l.undirectedLoops++,i._undirectedSelfLoopCount++)):(l.outDegree++,c.inDegree++,O&&(l.directedLoops++,i._directedSelfLoopCount++)),i.multi?h.attachMulti():h.attach(),n?i._undirectedSize++:i._directedSize++,v.key=s,i.emit("edgeAdded",v),[s,!0,L,S]}function fe(i,t){i._edges.delete(t.key);const{source:e,target:n,attributes:s}=t,o=t.undirected,r=e===n;o?(e.undirectedDegree--,n.undirectedDegree--,r&&(e.undirectedLoops--,i._undirectedSelfLoopCount--)):(e.outDegree--,n.inDegree--,r&&(e.directedLoops--,i._directedSelfLoopCount--)),i.multi?t.detachMulti():t.detach(),o?i._undirectedSize--:i._directedSize--,i.emit("edgeDropped",{key:t.key,attributes:s,source:e.key,target:n.key,undirected:o})}class N extends Se.EventEmitter{constructor(t){if(super(),t=R({},si,t),typeof t.multi!="boolean")throw new g(`Graph.constructor: invalid 'multi' option. Expecting a boolean but got "${t.multi}".`);if(!ri.has(t.type))throw new g(`Graph.constructor: invalid 'type' option. Should be one of "mixed", "directed" or "undirected" but got "${t.type}".`);if(typeof t.allowSelfLoops!="boolean")throw new g(`Graph.constructor: invalid 'allowSelfLoops' option. Expecting a boolean but got "${t.allowSelfLoops}".`);const e=t.type==="mixed"?ft:t.type==="directed"?lt:pt;F(this,"NodeDataClass",e);const n="geid_"+ii()+"_";let s=0;const o=()=>{let r;do r=n+s++;while(this._edges.has(r));return r};F(this,"_attributes",{}),F(this,"_nodes",new Map),F(this,"_edges",new Map),F(this,"_directedSize",0),F(this,"_undirectedSize",0),F(this,"_directedSelfLoopCount",0),F(this,"_undirectedSelfLoopCount",0),F(this,"_edgeKeyGenerator",o),F(this,"_options",t),Je.forEach(r=>F(this,r,this[r])),Y(this,"order",()=>this._nodes.size),Y(this,"size",()=>this._edges.size),Y(this,"directedSize",()=>this._directedSize),Y(this,"undirectedSize",()=>this._undirectedSize),Y(this,"selfLoopCount",()=>this._directedSelfLoopCount+this._undirectedSelfLoopCount),Y(this,"directedSelfLoopCount",()=>this._directedSelfLoopCount),Y(this,"undirectedSelfLoopCount",()=>this._undirectedSelfLoopCount),Y(this,"multi",this._options.multi),Y(this,"type",this._options.type),Y(this,"allowSelfLoops",this._options.allowSelfLoops),Y(this,"implementation",()=>"graphology")}_resetInstanceCounters(){this._directedSize=0,this._undirectedSize=0,this._directedSelfLoopCount=0,this._undirectedSelfLoopCount=0}hasNode(t){return this._nodes.has(""+t)}hasDirectedEdge(t,e){if(this.type==="undirected")return!1;if(arguments.length===1){const n=""+t,s=this._edges.get(n);return!!s&&!s.undirected}else if(arguments.length===2){t=""+t,e=""+e;const n=this._nodes.get(t);return n?n.out.hasOwnProperty(e):!1}throw new g(`Graph.hasDirectedEdge: invalid arity (${arguments.length}, instead of 1 or 2). You can either ask for an edge id or for the existence of an edge between a source & a target.`)}hasUndirectedEdge(t,e){if(this.type==="directed")return!1;if(arguments.length===1){const n=""+t,s=this._edges.get(n);return!!s&&s.undirected}else if(arguments.length===2){t=""+t,e=""+e;const n=this._nodes.get(t);return n?n.undirected.hasOwnProperty(e):!1}throw new g(`Graph.hasDirectedEdge: invalid arity (${arguments.length}, instead of 1 or 2). You can either ask for an edge id or for the existence of an edge between a source & a target.`)}hasEdge(t,e){if(arguments.length===1){const n=""+t;return this._edges.has(n)}else if(arguments.length===2){t=""+t,e=""+e;const n=this._nodes.get(t);return n?typeof n.out<"u"&&n.out.hasOwnProperty(e)||typeof n.undirected<"u"&&n.undirected.hasOwnProperty(e):!1}throw new g(`Graph.hasEdge: invalid arity (${arguments.length}, instead of 1 or 2). You can either ask for an edge id or for the existence of an edge between a source & a target.`)}directedEdge(t,e){if(this.type==="undirected")return;if(t=""+t,e=""+e,this.multi)throw new w("Graph.directedEdge: this method is irrelevant with multigraphs since there might be multiple edges between source & target. See #.directedEdges instead.");const n=this._nodes.get(t);if(!n)throw new p(`Graph.directedEdge: could not find the "${t}" source node in the graph.`);if(!this._nodes.has(e))throw new p(`Graph.directedEdge: could not find the "${e}" target node in the graph.`);const s=n.out&&n.out[e]||void 0;if(s)return s.key}undirectedEdge(t,e){if(this.type==="directed")return;if(t=""+t,e=""+e,this.multi)throw new w("Graph.undirectedEdge: this method is irrelevant with multigraphs since there might be multiple edges between source & target. See #.undirectedEdges instead.");const n=this._nodes.get(t);if(!n)throw new p(`Graph.undirectedEdge: could not find the "${t}" source node in the graph.`);if(!this._nodes.has(e))throw new p(`Graph.undirectedEdge: could not find the "${e}" target node in the graph.`);const s=n.undirected&&n.undirected[e]||void 0;if(s)return s.key}edge(t,e){if(this.multi)throw new w("Graph.edge: this method is irrelevant with multigraphs since there might be multiple edges between source & target. See #.edges instead.");t=""+t,e=""+e;const n=this._nodes.get(t);if(!n)throw new p(`Graph.edge: could not find the "${t}" source node in the graph.`);if(!this._nodes.has(e))throw new p(`Graph.edge: could not find the "${e}" target node in the graph.`);const s=n.out&&n.out[e]||n.undirected&&n.undirected[e]||void 0;if(s)return s.key}areDirectedNeighbors(t,e){t=""+t,e=""+e;const n=this._nodes.get(t);if(!n)throw new p(`Graph.areDirectedNeighbors: could not find the "${t}" node in the graph.`);return this.type==="undirected"?!1:e in n.in||e in n.out}areOutNeighbors(t,e){t=""+t,e=""+e;const n=this._nodes.get(t);if(!n)throw new p(`Graph.areOutNeighbors: could not find the "${t}" node in the graph.`);return this.type==="undirected"?!1:e in n.out}areInNeighbors(t,e){t=""+t,e=""+e;const n=this._nodes.get(t);if(!n)throw new p(`Graph.areInNeighbors: could not find the "${t}" node in the graph.`);return this.type==="undirected"?!1:e in n.in}areUndirectedNeighbors(t,e){t=""+t,e=""+e;const n=this._nodes.get(t);if(!n)throw new p(`Graph.areUndirectedNeighbors: could not find the "${t}" node in the graph.`);return this.type==="directed"?!1:e in n.undirected}areNeighbors(t,e){t=""+t,e=""+e;const n=this._nodes.get(t);if(!n)throw new p(`Graph.areNeighbors: could not find the "${t}" node in the graph.`);return this.type!=="undirected"&&(e in n.in||e in n.out)||this.type!=="directed"&&e in n.undirected}areInboundNeighbors(t,e){t=""+t,e=""+e;const n=this._nodes.get(t);if(!n)throw new p(`Graph.areInboundNeighbors: could not find the "${t}" node in the graph.`);return this.type!=="undirected"&&e in n.in||this.type!=="directed"&&e in n.undirected}areOutboundNeighbors(t,e){t=""+t,e=""+e;const n=this._nodes.get(t);if(!n)throw new p(`Graph.areOutboundNeighbors: could not find the "${t}" node in the graph.`);return this.type!=="undirected"&&e in n.out||this.type!=="directed"&&e in n.undirected}inDegree(t){t=""+t;const e=this._nodes.get(t);if(!e)throw new p(`Graph.inDegree: could not find the "${t}" node in the graph.`);return this.type==="undirected"?0:e.inDegree}outDegree(t){t=""+t;const e=this._nodes.get(t);if(!e)throw new p(`Graph.outDegree: could not find the "${t}" node in the graph.`);return this.type==="undirected"?0:e.outDegree}directedDegree(t){t=""+t;const e=this._nodes.get(t);if(!e)throw new p(`Graph.directedDegree: could not find the "${t}" node in the graph.`);return this.type==="undirected"?0:e.inDegree+e.outDegree}undirectedDegree(t){t=""+t;const e=this._nodes.get(t);if(!e)throw new p(`Graph.undirectedDegree: could not find the "${t}" node in the graph.`);return this.type==="directed"?0:e.undirectedDegree}inboundDegree(t){t=""+t;const e=this._nodes.get(t);if(!e)throw new p(`Graph.inboundDegree: could not find the "${t}" node in the graph.`);let n=0;return this.type!=="directed"&&(n+=e.undirectedDegree),this.type!=="undirected"&&(n+=e.inDegree),n}outboundDegree(t){t=""+t;const e=this._nodes.get(t);if(!e)throw new p(`Graph.outboundDegree: could not find the "${t}" node in the graph.`);let n=0;return this.type!=="directed"&&(n+=e.undirectedDegree),this.type!=="undirected"&&(n+=e.outDegree),n}degree(t){t=""+t;const e=this._nodes.get(t);if(!e)throw new p(`Graph.degree: could not find the "${t}" node in the graph.`);let n=0;return this.type!=="directed"&&(n+=e.undirectedDegree),this.type!=="undirected"&&(n+=e.inDegree+e.outDegree),n}inDegreeWithoutSelfLoops(t){t=""+t;const e=this._nodes.get(t);if(!e)throw new p(`Graph.inDegreeWithoutSelfLoops: could not find the "${t}" node in the graph.`);return this.type==="undirected"?0:e.inDegree-e.directedLoops}outDegreeWithoutSelfLoops(t){t=""+t;const e=this._nodes.get(t);if(!e)throw new p(`Graph.outDegreeWithoutSelfLoops: could not find the "${t}" node in the graph.`);return this.type==="undirected"?0:e.outDegree-e.directedLoops}directedDegreeWithoutSelfLoops(t){t=""+t;const e=this._nodes.get(t);if(!e)throw new p(`Graph.directedDegreeWithoutSelfLoops: could not find the "${t}" node in the graph.`);return this.type==="undirected"?0:e.inDegree+e.outDegree-e.directedLoops*2}undirectedDegreeWithoutSelfLoops(t){t=""+t;const e=this._nodes.get(t);if(!e)throw new p(`Graph.undirectedDegreeWithoutSelfLoops: could not find the "${t}" node in the graph.`);return this.type==="directed"?0:e.undirectedDegree-e.undirectedLoops*2}inboundDegreeWithoutSelfLoops(t){t=""+t;const e=this._nodes.get(t);if(!e)throw new p(`Graph.inboundDegreeWithoutSelfLoops: could not find the "${t}" node in the graph.`);let n=0,s=0;return this.type!=="directed"&&(n+=e.undirectedDegree,s+=e.undirectedLoops*2),this.type!=="undirected"&&(n+=e.inDegree,s+=e.directedLoops),n-s}outboundDegreeWithoutSelfLoops(t){t=""+t;const e=this._nodes.get(t);if(!e)throw new p(`Graph.outboundDegreeWithoutSelfLoops: could not find the "${t}" node in the graph.`);let n=0,s=0;return this.type!=="directed"&&(n+=e.undirectedDegree,s+=e.undirectedLoops*2),this.type!=="undirected"&&(n+=e.outDegree,s+=e.directedLoops),n-s}degreeWithoutSelfLoops(t){t=""+t;const e=this._nodes.get(t);if(!e)throw new p(`Graph.degreeWithoutSelfLoops: could not find the "${t}" node in the graph.`);let n=0,s=0;return this.type!=="directed"&&(n+=e.undirectedDegree,s+=e.undirectedLoops*2),this.type!=="undirected"&&(n+=e.inDegree+e.outDegree,s+=e.directedLoops*2),n-s}source(t){t=""+t;const e=this._edges.get(t);if(!e)throw new p(`Graph.source: could not find the "${t}" edge in the graph.`);return e.source.key}target(t){t=""+t;const e=this._edges.get(t);if(!e)throw new p(`Graph.target: could not find the "${t}" edge in the graph.`);return e.target.key}extremities(t){t=""+t;const e=this._edges.get(t);if(!e)throw new p(`Graph.extremities: could not find the "${t}" edge in the graph.`);return[e.source.key,e.target.key]}opposite(t,e){t=""+t,e=""+e;const n=this._edges.get(e);if(!n)throw new p(`Graph.opposite: could not find the "${e}" edge in the graph.`);const s=n.source.key,o=n.target.key;if(t===s)return o;if(t===o)return s;throw new p(`Graph.opposite: the "${t}" node is not attached to the "${e}" edge (${s}, ${o}).`)}hasExtremity(t,e){t=""+t,e=""+e;const n=this._edges.get(t);if(!n)throw new p(`Graph.hasExtremity: could not find the "${t}" edge in the graph.`);return n.source.key===e||n.target.key===e}isUndirected(t){t=""+t;const e=this._edges.get(t);if(!e)throw new p(`Graph.isUndirected: could not find the "${t}" edge in the graph.`);return e.undirected}isDirected(t){t=""+t;const e=this._edges.get(t);if(!e)throw new p(`Graph.isDirected: could not find the "${t}" edge in the graph.`);return!e.undirected}isSelfLoop(t){t=""+t;const e=this._edges.get(t);if(!e)throw new p(`Graph.isSelfLoop: could not find the "${t}" edge in the graph.`);return e.source===e.target}addNode(t,e){return ai(this,t,e).key}mergeNode(t,e){if(e&&!T(e))throw new g(`Graph.mergeNode: invalid attributes. Expecting an object but got "${e}"`);t=""+t,e=e||{};let n=this._nodes.get(t);return n?(e&&(R(n.attributes,e),this.emit("nodeAttributesUpdated",{type:"merge",key:t,attributes:n.attributes,data:e})),[t,!1]):(n=new this.NodeDataClass(t,e),this._nodes.set(t,n),this.emit("nodeAdded",{key:t,attributes:e}),[t,!0])}updateNode(t,e){if(e&&typeof e!="function")throw new g(`Graph.updateNode: invalid updater function. Expecting a function but got "${e}"`);t=""+t;let n=this._nodes.get(t);if(n){if(e){const o=n.attributes;n.attributes=e(o),this.emit("nodeAttributesUpdated",{type:"replace",key:t,attributes:n.attributes})}return[t,!1]}const s=e?e({}):{};return n=new this.NodeDataClass(t,s),this._nodes.set(t,n),this.emit("nodeAdded",{key:t,attributes:s}),[t,!0]}dropNode(t){t=""+t;const e=this._nodes.get(t);if(!e)throw new p(`Graph.dropNode: could not find the "${t}" node in the graph.`);let n;if(this.type!=="undirected"){for(const s in e.out){n=e.out[s];do fe(this,n),n=n.next;while(n)}for(const s in e.in){n=e.in[s];do fe(this,n),n=n.next;while(n)}}if(this.type!=="directed")for(const s in e.undirected){n=e.undirected[s];do fe(this,n),n=n.next;while(n)}this._nodes.delete(t),this.emit("nodeDropped",{key:t,attributes:e.attributes})}dropEdge(t){let e;if(arguments.length>1){const n=""+arguments[0],s=""+arguments[1];if(e=V(this,n,s,this.type),!e)throw new p(`Graph.dropEdge: could not find the "${n}" -> "${s}" edge in the graph.`)}else if(t=""+t,e=this._edges.get(t),!e)throw new p(`Graph.dropEdge: could not find the "${t}" edge in the graph.`);return fe(this,e),this}dropDirectedEdge(t,e){if(arguments.length<2)throw new w("Graph.dropDirectedEdge: it does not make sense to try and drop a directed edge by key. What if the edge with this key is undirected? Use #.dropEdge for this purpose instead.");if(this.multi)throw new w("Graph.dropDirectedEdge: cannot use a {source,target} combo when dropping an edge in a MultiGraph since we cannot infer the one you want to delete as there could be multiple ones.");t=""+t,e=""+e;const n=V(this,t,e,"directed");if(!n)throw new p(`Graph.dropDirectedEdge: could not find a "${t}" -> "${e}" edge in the graph.`);return fe(this,n),this}dropUndirectedEdge(t,e){if(arguments.length<2)throw new w("Graph.dropUndirectedEdge: it does not make sense to drop a directed edge by key. What if the edge with this key is undirected? Use #.dropEdge for this purpose instead.");if(this.multi)throw new w("Graph.dropUndirectedEdge: cannot use a {source,target} combo when dropping an edge in a MultiGraph since we cannot infer the one you want to delete as there could be multiple ones.");const n=V(this,t,e,"undirected");if(!n)throw new p(`Graph.dropUndirectedEdge: could not find a "${t}" -> "${e}" edge in the graph.`);return fe(this,n),this}clear(){this._edges.clear(),this._nodes.clear(),this._resetInstanceCounters(),this.emit("cleared")}clearEdges(){const t=this._nodes.values();let e;for(;e=t.next(),e.done!==!0;)e.value.clear();this._edges.clear(),this._resetInstanceCounters(),this.emit("edgesCleared")}getAttribute(t){return this._attributes[t]}getAttributes(){return this._attributes}hasAttribute(t){return this._attributes.hasOwnProperty(t)}setAttribute(t,e){return this._attributes[t]=e,this.emit("attributesUpdated",{type:"set",attributes:this._attributes,name:t}),this}updateAttribute(t,e){if(typeof e!="function")throw new g("Graph.updateAttribute: updater should be a function.");const n=this._attributes[t];return this._attributes[t]=e(n),this.emit("attributesUpdated",{type:"set",attributes:this._attributes,name:t}),this}removeAttribute(t){return delete this._attributes[t],this.emit("attributesUpdated",{type:"remove",attributes:this._attributes,name:t}),this}replaceAttributes(t){if(!T(t))throw new g("Graph.replaceAttributes: provided attributes are not a plain object.");return this._attributes=t,this.emit("attributesUpdated",{type:"replace",attributes:this._attributes}),this}mergeAttributes(t){if(!T(t))throw new g("Graph.mergeAttributes: provided attributes are not a plain object.");return R(this._attributes,t),this.emit("attributesUpdated",{type:"merge",attributes:this._attributes,data:t}),this}updateAttributes(t){if(typeof t!="function")throw new g("Graph.updateAttributes: provided updater is not a function.");return this._attributes=t(this._attributes),this.emit("attributesUpdated",{type:"update",attributes:this._attributes}),this}updateEachNodeAttributes(t,e){if(typeof t!="function")throw new g("Graph.updateEachNodeAttributes: expecting an updater function.");if(e&&!Ye(e))throw new g("Graph.updateEachNodeAttributes: invalid hints. Expecting an object having the following shape: {attributes?: [string]}");const n=this._nodes.values();let s,o;for(;s=n.next(),s.done!==!0;)o=s.value,o.attributes=t(o.key,o.attributes);this.emit("eachNodeAttributesUpdated",{hints:e||null})}updateEachEdgeAttributes(t,e){if(typeof t!="function")throw new g("Graph.updateEachEdgeAttributes: expecting an updater function.");if(e&&!Ye(e))throw new g("Graph.updateEachEdgeAttributes: invalid hints. Expecting an object having the following shape: {attributes?: [string]}");const n=this._edges.values();let s,o,r,a;for(;s=n.next(),s.done!==!0;)o=s.value,r=o.source,a=o.target,o.attributes=t(o.key,o.attributes,r.key,a.key,r.attributes,a.attributes,o.undirected);this.emit("eachEdgeAttributesUpdated",{hints:e||null})}forEachAdjacencyEntry(t){if(typeof t!="function")throw new g("Graph.forEachAdjacencyEntry: expecting a callback.");Ae(!1,!1,!1,this,t)}forEachAdjacencyEntryWithOrphans(t){if(typeof t!="function")throw new g("Graph.forEachAdjacencyEntryWithOrphans: expecting a callback.");Ae(!1,!1,!0,this,t)}forEachAssymetricAdjacencyEntry(t){if(typeof t!="function")throw new g("Graph.forEachAssymetricAdjacencyEntry: expecting a callback.");Ae(!1,!0,!1,this,t)}forEachAssymetricAdjacencyEntryWithOrphans(t){if(typeof t!="function")throw new g("Graph.forEachAssymetricAdjacencyEntryWithOrphans: expecting a callback.");Ae(!1,!0,!0,this,t)}nodes(){return typeof Array.from=="function"?Array.from(this._nodes.keys()):ht(this._nodes.keys(),this._nodes.size)}forEachNode(t){if(typeof t!="function")throw new g("Graph.forEachNode: expecting a callback.");const e=this._nodes.values();let n,s;for(;n=e.next(),n.done!==!0;)s=n.value,t(s.key,s.attributes)}findNode(t){if(typeof t!="function")throw new g("Graph.findNode: expecting a callback.");const e=this._nodes.values();let n,s;for(;n=e.next(),n.done!==!0;)if(s=n.value,t(s.key,s.attributes))return s.key}mapNodes(t){if(typeof t!="function")throw new g("Graph.mapNode: expecting a callback.");const e=this._nodes.values();let n,s;const o=new Array(this.order);let r=0;for(;n=e.next(),n.done!==!0;)s=n.value,o[r++]=t(s.key,s.attributes);return o}someNode(t){if(typeof t!="function")throw new g("Graph.someNode: expecting a callback.");const e=this._nodes.values();let n,s;for(;n=e.next(),n.done!==!0;)if(s=n.value,t(s.key,s.attributes))return!0;return!1}everyNode(t){if(typeof t!="function")throw new g("Graph.everyNode: expecting a callback.");const e=this._nodes.values();let n,s;for(;n=e.next(),n.done!==!0;)if(s=n.value,!t(s.key,s.attributes))return!1;return!0}filterNodes(t){if(typeof t!="function")throw new g("Graph.filterNodes: expecting a callback.");const e=this._nodes.values();let n,s;const o=[];for(;n=e.next(),n.done!==!0;)s=n.value,t(s.key,s.attributes)&&o.push(s.key);return o}reduceNodes(t,e){if(typeof t!="function")throw new g("Graph.reduceNodes: expecting a callback.");if(arguments.length<2)throw new g("Graph.reduceNodes: missing initial value. You must provide it because the callback takes more than one argument and we cannot infer the initial value from the first iteration, as you could with a simple array.");let n=e;const s=this._nodes.values();let o,r;for(;o=s.next(),o.done!==!0;)r=o.value,n=t(n,r.key,r.attributes);return n}nodeEntries(){const t=this._nodes.values();return new K(()=>{const e=t.next();if(e.done)return e;const n=e.value;return{value:{node:n.key,attributes:n.attributes},done:!1}})}export(){const t=new Array(this._nodes.size);let e=0;this._nodes.forEach((s,o)=>{t[e++]=Mn(o,s)});const n=new Array(this._edges.size);return e=0,this._edges.forEach((s,o)=>{n[e++]=ei(this.type,o,s)}),{options:{type:this.type,multi:this.multi,allowSelfLoops:this.allowSelfLoops},attributes:this.getAttributes(),nodes:t,edges:n}}import(t,e=!1){if(t instanceof N)return t.forEachNode((u,d)=>{e?this.mergeNode(u,d):this.addNode(u,d)}),t.forEachEdge((u,d,l,c,h,y,v)=>{e?v?this.mergeUndirectedEdgeWithKey(u,l,c,d):this.mergeDirectedEdgeWithKey(u,l,c,d):v?this.addUndirectedEdgeWithKey(u,l,c,d):this.addDirectedEdgeWithKey(u,l,c,d)}),this;if(!T(t))throw new g("Graph.import: invalid argument. Expecting a serialized graph or, alternatively, a Graph instance.");if(t.attributes){if(!T(t.attributes))throw new g("Graph.import: invalid attributes. Expecting a plain object.");e?this.mergeAttributes(t.attributes):this.replaceAttributes(t.attributes)}let n,s,o,r,a;if(t.nodes){if(o=t.nodes,!Array.isArray(o))throw new g("Graph.import: invalid nodes. Expecting an array.");for(n=0,s=o.length;n<s;n++){r=o[n],ti(r);const{key:u,attributes:d}=r;e?this.mergeNode(u,d):this.addNode(u,d)}}if(t.edges){let u=!1;if(this.type==="undirected"&&(u=!0),o=t.edges,!Array.isArray(o))throw new g("Graph.import: invalid edges. Expecting an array.");for(n=0,s=o.length;n<s;n++){a=o[n],ni(a);const{source:d,target:l,attributes:c,undirected:h=u}=a;let y;"key"in a?(y=e?h?this.mergeUndirectedEdgeWithKey:this.mergeDirectedEdgeWithKey:h?this.addUndirectedEdgeWithKey:this.addDirectedEdgeWithKey,y.call(this,a.key,d,l,c)):(y=e?h?this.mergeUndirectedEdge:this.mergeDirectedEdge:h?this.addUndirectedEdge:this.addDirectedEdge,y.call(this,d,l,c))}}return this}nullCopy(t){const e=new N(R({},this._options,t));return e.replaceAttributes(R({},this.getAttributes())),e}emptyCopy(t){const e=this.nullCopy(t);return this._nodes.forEach((n,s)=>{const o=R({},n.attributes);n=new e.NodeDataClass(s,o),e._nodes.set(s,n)}),e}copy(t){if(t=t||{},typeof t.type=="string"&&t.type!==this.type&&t.type!=="mixed")throw new w(`Graph.copy: cannot create an incompatible copy from "${this.type}" type to "${t.type}" because this would mean losing information about the current graph.`);if(typeof t.multi=="boolean"&&t.multi!==this.multi&&t.multi!==!0)throw new w("Graph.copy: cannot create an incompatible copy by downgrading a multi graph to a simple one because this would mean losing information about the current graph.");if(typeof t.allowSelfLoops=="boolean"&&t.allowSelfLoops!==this.allowSelfLoops&&t.allowSelfLoops!==!0)throw new w("Graph.copy: cannot create an incompatible copy from a graph allowing self loops to one that does not because this would mean losing information about the current graph.");const e=this.emptyCopy(t),n=this._edges.values();let s,o;for(;s=n.next(),s.done!==!0;)o=s.value,bt(e,"copy",!1,o.undirected,o.key,o.source.key,o.target.key,R({},o.attributes));return e}toJSON(){return this.export()}toString(){return"[object Graph]"}inspect(){const t={};this._nodes.forEach((o,r)=>{t[r]=o.attributes});const e={},n={};this._edges.forEach((o,r)=>{const a=o.undirected?"--":"->";let u="",d=o.source.key,l=o.target.key,c;o.undirected&&d>l&&(c=d,d=l,l=c);const h=`(${d})${a}(${l})`;r.startsWith("geid_")?this.multi&&(typeof n[h]>"u"?n[h]=0:n[h]++,u+=`${n[h]}. `):u+=`[${r}]: `,u+=h,e[u]=o.attributes});const s={};for(const o in this)this.hasOwnProperty(o)&&!Je.has(o)&&typeof this[o]!="function"&&typeof o!="symbol"&&(s[o]=this[o]);return s.attributes=this._attributes,s.nodes=t,s.edges=e,F(s,"constructor",this.constructor),s}}typeof Symbol<"u"&&(N.prototype[Symbol.for("nodejs.util.inspect.custom")]=N.prototype.inspect);oi.forEach(i=>{["add","merge","update"].forEach(t=>{const e=i.name(t),n=t==="add"?bt:ui;i.generateKey?N.prototype[e]=function(s,o,r){return n(this,e,!0,(i.type||this.type)==="undirected",null,s,o,r,t==="update")}:N.prototype[e]=function(s,o,r,a){return n(this,e,!1,(i.type||this.type)==="undirected",s,o,r,a,t==="update")}})});wn(N);Nn(N);Fn(N);Xn(N);class vt extends N{constructor(t){const e=R({type:"directed"},t);if("multi"in e&&e.multi!==!1)throw new g("DirectedGraph.from: inconsistent indication that the graph should be multi in given options!");if(e.type!=="directed")throw new g('DirectedGraph.from: inconsistent "'+e.type+'" type in given options!');super(e)}}class Et extends N{constructor(t){const e=R({type:"undirected"},t);if("multi"in e&&e.multi!==!1)throw new g("UndirectedGraph.from: inconsistent indication that the graph should be multi in given options!");if(e.type!=="undirected")throw new g('UndirectedGraph.from: inconsistent "'+e.type+'" type in given options!');super(e)}}class _t extends N{constructor(t){const e=R({multi:!0},t);if("multi"in e&&e.multi!==!0)throw new g("MultiGraph.from: inconsistent indication that the graph should be simple in given options!");super(e)}}class $t extends N{constructor(t){const e=R({type:"directed",multi:!0},t);if("multi"in e&&e.multi!==!0)throw new g("MultiDirectedGraph.from: inconsistent indication that the graph should be simple in given options!");if(e.type!=="directed")throw new g('MultiDirectedGraph.from: inconsistent "'+e.type+'" type in given options!');super(e)}}class Gt extends N{constructor(t){const e=R({type:"undirected",multi:!0},t);if("multi"in e&&e.multi!==!0)throw new g("MultiUndirectedGraph.from: inconsistent indication that the graph should be simple in given options!");if(e.type!=="undirected")throw new g('MultiUndirectedGraph.from: inconsistent "'+e.type+'" type in given options!');super(e)}}function ge(i){i.from=function(t,e){const n=R({},t.options,e),s=new i(n);return s.import(t),s}}ge(N);ge(vt);ge(Et);ge(_t);ge($t);ge(Gt);N.Graph=N;N.DirectedGraph=vt;N.UndirectedGraph=Et;N.MultiGraph=_t;N.MultiDirectedGraph=$t;N.MultiUndirectedGraph=Gt;N.InvalidArgumentsGraphError=g;N.NotFoundGraphError=p;N.UsageGraphError=w;function di(i){return!i||typeof i!="object"||typeof i=="function"||Array.isArray(i)||i instanceof Set||i instanceof Map||i instanceof RegExp||i instanceof Date}function kt(i,t){i=i||{};var e={};for(var n in t){var s=i[n],o=t[n];if(!di(o)){e[n]=kt(s,o);continue}s===void 0?e[n]=o:e[n]=s}return e}var hi=kt,Dt=function(t){return t!==null&&typeof t=="object"&&typeof t.addUndirectedEdgeWithKey=="function"&&typeof t.dropNode=="function"&&typeof t.multi=="boolean"},ci=hi,fi=Dt,li={dimensions:["x","y"],center:.5,scale:1};function At(i,t,e){if(!fi(t))throw new Error("graphology-layout/random: the given graph is not a valid graphology instance.");e=ci(e,li);var n=e.dimensions;if(!Array.isArray(n)||n.length!==2)throw new Error("graphology-layout/random: given dimensions are invalid.");var s=e.center,o=e.scale,r=Math.PI*2,a=(s-.5)*o,u=t.order,d=n[0],l=n[1];function c(v,L){return L[d]=o*Math.cos(v*r/u)+a,L[l]=o*Math.sin(v*r/u)+a,L}var h=0;if(!i){var y={};return t.forEachNode(function(v){y[v]=c(h++,{})}),y}t.updateEachNodeAttributes(function(v,L){return c(h++,L),L},{attributes:n})}var Nt=At.bind(null,!1);Nt.assign=At.bind(null,!0);var pi=Nt;const gi=pi;var Oe={};function yi(i){return typeof i!="number"||isNaN(i)?1:i}function wi(i,t){var e={},n=function(r){return typeof r>"u"?t:r};typeof t=="function"&&(n=t);var s=function(r){return n(r[i])},o=function(){return n(void 0)};return typeof i=="string"?(e.fromAttributes=s,e.fromGraph=function(r,a){return s(r.getNodeAttributes(a))},e.fromEntry=function(r,a){return s(a)}):typeof i=="function"?(e.fromAttributes=function(){throw new Error("graphology-utils/getters/createNodeValueGetter: irrelevant usage.")},e.fromGraph=function(r,a){return n(i(a,r.getNodeAttributes(a)))},e.fromEntry=function(r,a){return n(i(r,a))}):(e.fromAttributes=o,e.fromGraph=o,e.fromEntry=o),e}function Lt(i,t){var e={},n=function(r){return typeof r>"u"?t:r};typeof t=="function"&&(n=t);var s=function(r){return n(r[i])},o=function(){return n(void 0)};return typeof i=="string"?(e.fromAttributes=s,e.fromGraph=function(r,a){return s(r.getEdgeAttributes(a))},e.fromEntry=function(r,a){return s(a)},e.fromPartialEntry=e.fromEntry,e.fromMinimalEntry=e.fromEntry):typeof i=="function"?(e.fromAttributes=function(){throw new Error("graphology-utils/getters/createEdgeValueGetter: irrelevant usage.")},e.fromGraph=function(r,a){var u=r.extremities(a);return n(i(a,r.getEdgeAttributes(a),u[0],u[1],r.getNodeAttributes(u[0]),r.getNodeAttributes(u[1]),r.isUndirected(a)))},e.fromEntry=function(r,a,u,d,l,c,h){return n(i(r,a,u,d,l,c,h))},e.fromPartialEntry=function(r,a,u,d){return n(i(r,a,u,d))},e.fromMinimalEntry=function(r,a){return n(i(r,a))}):(e.fromAttributes=o,e.fromGraph=o,e.fromEntry=o,e.fromMinimalEntry=o),e}Oe.createNodeValueGetter=wi;Oe.createEdgeValueGetter=Lt;Oe.createEdgeWeightGetter=function(i){return Lt(i,yi)};var I=0,x=1,_=2,$=3,M=4,ee=5,k=6,Ze=7,Ne=8,Qe=9,mi=0,bi=1,vi=2,C=0,H=1,z=2,ue=3,ie=4,U=5,W=6,q=7,Z=8,Xe=3,J=10,Ei=3,j=9,Te=10,_i=function(t,e,n){var s,o,r,a,u,d,l,c,h,y,v=e.length,L=n.length,S=t.adjustSizes,O=t.barnesHutTheta*t.barnesHutTheta,P,D,E,G,X,b,m,f=[];for(r=0;r<v;r+=J)e[r+M]=e[r+_],e[r+ee]=e[r+$],e[r+_]=0,e[r+$]=0;if(t.outboundAttractionDistribution){for(P=0,r=0;r<v;r+=J)P+=e[r+k];P/=v/J}if(t.barnesHutOptimize){var oe=1/0,de=-1/0,se=1/0,he=-1/0,B,ce,Ie;for(r=0;r<v;r+=J)oe=Math.min(oe,e[r+I]),de=Math.max(de,e[r+I]),se=Math.min(se,e[r+x]),he=Math.max(he,e[r+x]);var Ee=de-oe,_e=he-se;for(Ee>_e?(se-=(Ee-_e)/2,he=se+Ee):(oe-=(_e-Ee)/2,de=oe+_e),f[0+C]=-1,f[0+H]=(oe+de)/2,f[0+z]=(se+he)/2,f[0+ue]=Math.max(de-oe,he-se),f[0+ie]=-1,f[0+U]=-1,f[0+W]=0,f[0+q]=0,f[0+Z]=0,s=1,r=0;r<v;r+=J)for(o=0,Ie=Xe;;)if(f[o+U]>=0){e[r+I]<f[o+H]?e[r+x]<f[o+z]?B=f[o+U]:B=f[o+U]+j:e[r+x]<f[o+z]?B=f[o+U]+j*2:B=f[o+U]+j*3,f[o+q]=(f[o+q]*f[o+W]+e[r+I]*e[r+k])/(f[o+W]+e[r+k]),f[o+Z]=(f[o+Z]*f[o+W]+e[r+x]*e[r+k])/(f[o+W]+e[r+k]),f[o+W]+=e[r+k],o=B;continue}else if(f[o+C]<0){f[o+C]=r;break}else{if(f[o+U]=s*j,c=f[o+ue]/2,h=f[o+U],f[h+C]=-1,f[h+H]=f[o+H]-c,f[h+z]=f[o+z]-c,f[h+ue]=c,f[h+ie]=h+j,f[h+U]=-1,f[h+W]=0,f[h+q]=0,f[h+Z]=0,h+=j,f[h+C]=-1,f[h+H]=f[o+H]-c,f[h+z]=f[o+z]+c,f[h+ue]=c,f[h+ie]=h+j,f[h+U]=-1,f[h+W]=0,f[h+q]=0,f[h+Z]=0,h+=j,f[h+C]=-1,f[h+H]=f[o+H]+c,f[h+z]=f[o+z]-c,f[h+ue]=c,f[h+ie]=h+j,f[h+U]=-1,f[h+W]=0,f[h+q]=0,f[h+Z]=0,h+=j,f[h+C]=-1,f[h+H]=f[o+H]+c,f[h+z]=f[o+z]+c,f[h+ue]=c,f[h+ie]=f[o+ie],f[h+U]=-1,f[h+W]=0,f[h+q]=0,f[h+Z]=0,s+=4,e[f[o+C]+I]<f[o+H]?e[f[o+C]+x]<f[o+z]?B=f[o+U]:B=f[o+U]+j:e[f[o+C]+x]<f[o+z]?B=f[o+U]+j*2:B=f[o+U]+j*3,f[o+W]=e[f[o+C]+k],f[o+q]=e[f[o+C]+I],f[o+Z]=e[f[o+C]+x],f[B+C]=f[o+C],f[o+C]=-1,e[r+I]<f[o+H]?e[r+x]<f[o+z]?ce=f[o+U]:ce=f[o+U]+j:e[r+x]<f[o+z]?ce=f[o+U]+j*2:ce=f[o+U]+j*3,B===ce)if(Ie--){o=B;continue}else{Ie=Xe;break}f[ce+C]=r;break}}if(t.barnesHutOptimize)for(D=t.scalingRatio,r=0;r<v;r+=J)for(o=0;;)if(f[o+U]>=0)if(b=Math.pow(e[r+I]-f[o+q],2)+Math.pow(e[r+x]-f[o+Z],2),y=f[o+ue],4*y*y/b<O){if(E=e[r+I]-f[o+q],G=e[r+x]-f[o+Z],S===!0?b>0?(m=D*e[r+k]*f[o+W]/b,e[r+_]+=E*m,e[r+$]+=G*m):b<0&&(m=-D*e[r+k]*f[o+W]/Math.sqrt(b),e[r+_]+=E*m,e[r+$]+=G*m):b>0&&(m=D*e[r+k]*f[o+W]/b,e[r+_]+=E*m,e[r+$]+=G*m),o=f[o+ie],o<0)break;continue}else{o=f[o+U];continue}else{if(d=f[o+C],d>=0&&d!==r&&(E=e[r+I]-e[d+I],G=e[r+x]-e[d+x],b=E*E+G*G,S===!0?b>0?(m=D*e[r+k]*e[d+k]/b,e[r+_]+=E*m,e[r+$]+=G*m):b<0&&(m=-D*e[r+k]*e[d+k]/Math.sqrt(b),e[r+_]+=E*m,e[r+$]+=G*m):b>0&&(m=D*e[r+k]*e[d+k]/b,e[r+_]+=E*m,e[r+$]+=G*m)),o=f[o+ie],o<0)break;continue}else for(D=t.scalingRatio,a=0;a<v;a+=J)for(u=0;u<a;u+=J)E=e[a+I]-e[u+I],G=e[a+x]-e[u+x],S===!0?(b=Math.sqrt(E*E+G*G)-e[a+Ne]-e[u+Ne],b>0?(m=D*e[a+k]*e[u+k]/b/b,e[a+_]+=E*m,e[a+$]+=G*m,e[u+_]-=E*m,e[u+$]-=G*m):b<0&&(m=100*D*e[a+k]*e[u+k],e[a+_]+=E*m,e[a+$]+=G*m,e[u+_]-=E*m,e[u+$]-=G*m)):(b=Math.sqrt(E*E+G*G),b>0&&(m=D*e[a+k]*e[u+k]/b/b,e[a+_]+=E*m,e[a+$]+=G*m,e[u+_]-=E*m,e[u+$]-=G*m));for(h=t.gravity/t.scalingRatio,D=t.scalingRatio,r=0;r<v;r+=J)m=0,E=e[r+I],G=e[r+x],b=Math.sqrt(Math.pow(E,2)+Math.pow(G,2)),t.strongGravityMode?b>0&&(m=D*e[r+k]*h):b>0&&(m=D*e[r+k]*h/b),e[r+_]-=E*m,e[r+$]-=G*m;for(D=1*(t.outboundAttractionDistribution?P:1),l=0;l<L;l+=Ei)a=n[l+mi],u=n[l+bi],c=n[l+vi],X=Math.pow(c,t.edgeWeightInfluence),E=e[a+I]-e[u+I],G=e[a+x]-e[u+x],S===!0?(b=Math.sqrt(E*E+G*G)-e[a+Ne]-e[u+Ne],t.linLogMode?t.outboundAttractionDistribution?b>0&&(m=-D*X*Math.log(1+b)/b/e[a+k]):b>0&&(m=-D*X*Math.log(1+b)/b):t.outboundAttractionDistribution?b>0&&(m=-D*X/e[a+k]):b>0&&(m=-D*X)):(b=Math.sqrt(Math.pow(E,2)+Math.pow(G,2)),t.linLogMode?t.outboundAttractionDistribution?b>0&&(m=-D*X*Math.log(1+b)/b/e[a+k]):b>0&&(m=-D*X*Math.log(1+b)/b):t.outboundAttractionDistribution?(b=1,m=-D*X/e[a+k]):(b=1,m=-D*X)),b>0&&(e[a+_]+=E*m,e[a+$]+=G*m,e[u+_]-=E*m,e[u+$]-=G*m);var $e,ye,Ge,ae,ke,De;if(S===!0)for(r=0;r<v;r+=J)e[r+Qe]!==1&&($e=Math.sqrt(Math.pow(e[r+_],2)+Math.pow(e[r+$],2)),$e>Te&&(e[r+_]=e[r+_]*Te/$e,e[r+$]=e[r+$]*Te/$e),ye=e[r+k]*Math.sqrt((e[r+M]-e[r+_])*(e[r+M]-e[r+_])+(e[r+ee]-e[r+$])*(e[r+ee]-e[r+$])),Ge=Math.sqrt((e[r+M]+e[r+_])*(e[r+M]+e[r+_])+(e[r+ee]+e[r+$])*(e[r+ee]+e[r+$]))/2,ae=.1*Math.log(1+Ge)/(1+Math.sqrt(ye)),ke=e[r+I]+e[r+_]*(ae/t.slowDown),e[r+I]=ke,De=e[r+x]+e[r+$]*(ae/t.slowDown),e[r+x]=De);else for(r=0;r<v;r+=J)e[r+Qe]!==1&&(ye=e[r+k]*Math.sqrt((e[r+M]-e[r+_])*(e[r+M]-e[r+_])+(e[r+ee]-e[r+$])*(e[r+ee]-e[r+$])),Ge=Math.sqrt((e[r+M]+e[r+_])*(e[r+M]+e[r+_])+(e[r+ee]+e[r+$])*(e[r+ee]+e[r+$]))/2,ae=e[r+Ze]*Math.log(1+Ge)/(1+Math.sqrt(ye)),e[r+Ze]=Math.min(1,Math.sqrt(ae*(Math.pow(e[r+_],2)+Math.pow(e[r+$],2))/(1+Math.sqrt(ye)))),ke=e[r+I]+e[r+_]*(ae/t.slowDown),e[r+I]=ke,De=e[r+x]+e[r+$]*(ae/t.slowDown),e[r+x]=De);return{}},re={},ve=10,Me=3;re.assign=function(i){i=i||{};var t=Array.prototype.slice.call(arguments).slice(1),e,n,s;for(e=0,s=t.length;e<s;e++)if(t[e])for(n in t[e])i[n]=t[e][n];return i};re.validateSettings=function(i){return"linLogMode"in i&&typeof i.linLogMode!="boolean"?{message:"the `linLogMode` setting should be a boolean."}:"outboundAttractionDistribution"in i&&typeof i.outboundAttractionDistribution!="boolean"?{message:"the `outboundAttractionDistribution` setting should be a boolean."}:"adjustSizes"in i&&typeof i.adjustSizes!="boolean"?{message:"the `adjustSizes` setting should be a boolean."}:"edgeWeightInfluence"in i&&typeof i.edgeWeightInfluence!="number"?{message:"the `edgeWeightInfluence` setting should be a number."}:"scalingRatio"in i&&!(typeof i.scalingRatio=="number"&&i.scalingRatio>=0)?{message:"the `scalingRatio` setting should be a number >= 0."}:"strongGravityMode"in i&&typeof i.strongGravityMode!="boolean"?{message:"the `strongGravityMode` setting should be a boolean."}:"gravity"in i&&!(typeof i.gravity=="number"&&i.gravity>=0)?{message:"the `gravity` setting should be a number >= 0."}:"slowDown"in i&&!(typeof i.slowDown=="number"||i.slowDown>=0)?{message:"the `slowDown` setting should be a number >= 0."}:"barnesHutOptimize"in i&&typeof i.barnesHutOptimize!="boolean"?{message:"the `barnesHutOptimize` setting should be a boolean."}:"barnesHutTheta"in i&&!(typeof i.barnesHutTheta=="number"&&i.barnesHutTheta>=0)?{message:"the `barnesHutTheta` setting should be a number >= 0."}:null};re.graphToByteArrays=function(i,t){var e=i.order,n=i.size,s={},o,r=new Float32Array(e*ve),a=new Float32Array(n*Me);return o=0,i.forEachNode(function(u,d){s[u]=o,r[o]=d.x,r[o+1]=d.y,r[o+2]=0,r[o+3]=0,r[o+4]=0,r[o+5]=0,r[o+6]=1,r[o+7]=1,r[o+8]=d.size||1,r[o+9]=d.fixed?1:0,o+=ve}),o=0,i.forEachEdge(function(u,d,l,c,h,y,v){var L=s[l],S=s[c],O=t(u,d,l,c,h,y,v);r[L+6]+=O,r[S+6]+=O,a[o]=L,a[o+1]=S,a[o+2]=O,o+=Me}),{nodes:r,edges:a}};re.assignLayoutChanges=function(i,t,e){var n=0;i.updateEachNodeAttributes(function(s,o){return o.x=t[n],o.y=t[n+1],n+=ve,e?e(s,o):o})};re.readGraphPositions=function(i,t){var e=0;i.forEachNode(function(n,s){t[e]=s.x,t[e+1]=s.y,e+=ve})};re.collectLayoutChanges=function(i,t,e){for(var n=i.nodes(),s={},o=0,r=0,a=t.length;o<a;o+=ve){if(e){var u=Object.assign({},i.getNodeAttributes(n[r]));u.x=t[o],u.y=t[o+1],u=e(n[r],u),s[n[r]]={x:u.x,y:u.y}}else s[n[r]]={x:t[o],y:t[o+1]};r++}return s};re.createWorker=function(t){var e=window.URL||window.webkitURL,n=t.toString(),s=e.createObjectURL(new Blob(["("+n+").call(this);"],{type:"text/javascript"})),o=new Worker(s);return e.revokeObjectURL(s),o};var $i={linLogMode:!1,outboundAttractionDistribution:!1,adjustSizes:!1,edgeWeightInfluence:1,scalingRatio:1,strongGravityMode:!1,gravity:1,slowDown:1,barnesHutOptimize:!1,barnesHutTheta:.5},Gi=Dt,ki=Oe.createEdgeWeightGetter,Di=_i,be=re,Ai=$i;function St(i,t,e){if(!Gi(t))throw new Error("graphology-layout-forceatlas2: the given graph is not a valid graphology instance.");typeof e=="number"&&(e={iterations:e});var n=e.iterations;if(typeof n!="number")throw new Error("graphology-layout-forceatlas2: invalid number of iterations.");if(n<=0)throw new Error("graphology-layout-forceatlas2: you should provide a positive number of iterations.");var s=ki("getEdgeWeight"in e?e.getEdgeWeight:"weight").fromEntry,o=typeof e.outputReducer=="function"?e.outputReducer:null,r=be.assign({},Ai,e.settings),a=be.validateSettings(r);if(a)throw new Error("graphology-layout-forceatlas2: "+a.message);var u=be.graphToByteArrays(t,s),d;for(d=0;d<n;d++)Di(r,u.nodes,u.edges);if(i){be.assignLayoutChanges(t,u.nodes,o);return}return be.collectLayoutChanges(t,u.nodes)}function Ni(i){var t=typeof i=="number"?i:i.order;return{barnesHutOptimize:t>2e3,strongGravityMode:!0,gravity:.05,scalingRatio:10,slowDown:1+Math.log(t)}}var Fe=St.bind(null,!1);Fe.assign=St.bind(null,!0);Fe.inferSettings=Ni;var Li=Fe;const Si=Li,xi=i=>(zt("data-v-356017b1"),i=i(),Wt(),i),Ui={style:{height:"calc(100vh - 60px)"}},Oi=xi(()=>je("div",{class:"c-my-panel"},[je("div",{class:"c-option-name",style:{"line-height":"25px",padding:"10px"}}," This layout uses a third-party layout algorithm: Sigma, and you can still use powerful features such as slot support in relation-graph, perfect integration. Sigma force-directed graph layout is a classic layout algorithm. ")],-1)),Ii=Ut({__name:"use-sigma-layout",setup(i){const t=Ot(),e={debug:!1,lineUseTextPath:!0,layout:{layoutName:"fixed"},defaultNodeShape:0,defaultLineShape:1,defaultJunctionPoint:"border",defaultNodeBorderWidth:0,defaultNodeWidth:30,defaultNodeHeight:30,defaultLineColor:"rgba(0, 186, 189, 1)",defaultNodeColor:"rgba(0, 206, 209, 1)"};It(async()=>{await n()});const n=async()=>{let r={rootId:"root",nodes:[{id:"root",text:"节点"},{id:"N2",text:"新节点N2"},{id:"N3",text:"新节点N3"},{id:"N4",text:"新节点N4"},{id:"N5",text:"新节点N5"},{id:"N6",text:"新节点N6"},{id:"N7",text:"新节点N7"},{id:"N8",text:"新节点N8"},{id:"N9",text:"新节点N9"},{id:"N10",text:"新节点N10"},{id:"N11",text:"新节点N11"},{id:"N12",text:"新节点N12"},{id:"N13",text:"新节点N13"},{id:"N14",text:"新节点N14"},{id:"N15",text:"新节点N15"},{id:"N16",text:"新节点N16"},{id:"N17",text:"新节点N17"},{id:"N18",text:"新节点N18"},{id:"N19",text:"新节点N19"},{id:"N20",text:"新节点N20"},{id:"N21",text:"新节点N21"},{id:"N22",text:"新节点N22"},{id:"N23",text:"新节点N23"},{id:"N24",text:"新节点N24"},{id:"N25",text:"新节点N25"},{id:"N26",text:"新节点N26"},{id:"N27",text:"New-N27"},{id:"N28",text:"New-N28"},{id:"N29",text:"New-N29"},{id:"N30",text:"New-N30"},{id:"N31",text:"New-N31"},{id:"N32",text:"New-N32"},{id:"N33",text:"New-N33"},{id:"N34",text:"New-N34"},{id:"N35",text:"New-N35"},{id:"N36",text:"New-N36"},{id:"N37",text:"New-N37"},{id:"N38",text:"New-N38"},{id:"N39",text:"New-N39"}],lines:[{from:"N3",to:"N2",text:"新连线1"},{from:"N2",to:"root",text:"新连线1"},{from:"root",to:"N4",text:"新连线2"},{from:"N4",to:"N5",text:"新连线3"},{from:"N6",to:"N7",text:"新连线2"},{from:"N7",to:"root",text:"新连线3"},{from:"N8",to:"N9",text:"新连线4"},{from:"N9",to:"root",text:"新连线5"},{from:"N10",to:"N11",text:"新连线6"},{from:"N11",to:"root",text:"新连线7"},{from:"N13",to:"N12",text:"新连线8"},{from:"N12",to:"root",text:"新连线9"},{from:"N18",to:"N17",text:"新连线10"},{from:"N17",to:"N14",text:"新连线11"},{from:"N15",to:"N14",text:"新连线12"},{from:"N16",to:"N15",text:"新连线13"},{from:"N12",to:"N14",text:"新连线14"},{from:"N20",to:"N19",text:"新连线15"},{from:"N21",to:"N19",text:"新连线16"},{from:"N19",to:"N15",text:"新连线17"},{from:"N26",to:"N22",text:"新连线18"},{from:"N24",to:"N25",text:"新连线19"},{from:"N24",to:"N22",text:"新连线20"},{from:"N22",to:"N23",text:"新连线21"},{from:"N23",to:"N14",text:"新连线22"},{from:"root",to:"N30",text:"新连线1"},{from:"root",to:"N27",text:"新连线2"},{from:"N30",to:"N33",text:"新连线3"},{from:"N30",to:"N29",text:"新连线4"},{from:"N27",to:"N28",text:"新连线5"},{from:"N27",to:"N31",text:"新连线6"},{from:"N27",to:"N32",text:"新连线7"},{from:"N4",to:"N34",text:"新连线8"},{from:"N28",to:"N35",text:"新连线9"},{from:"N28",to:"N36",text:"新连线12"},{from:"N28",to:"N37",text:"新连线13"},{from:"N36",to:"N39",text:"新连线14"},{from:"N36",to:"N38",text:"新连线15"}]};r.nodes.forEach(d=>{d.text="N"});const a=new N,u=t.value.getInstance();await u.setJsonData(r),u.getNodes().forEach(d=>{a.addNode(d.id,{text:d.text,width:d.el.offsetWidth,height:d.el.offsetHeight})}),u.getLinks().forEach(d=>{d.relations.forEach(l=>{a.addEdge(d.fromNode.id,d.toNode.id,{id:l.id,weight:1})})}),gi.assign(a),Si.assign(a,50),a.nodes().forEach(d=>{const l=a.getNodeAttributes(d),c=u.getNodeById(d);c.x=l.x*10,c.y=l.y*10})},s=(r,a)=>{console.log("onNodeClick:",r)},o=(r,a,u)=>{console.log("onLineClick:",r)};return(r,a)=>(Rt(),Ct("div",null,[je("div",Ui,[Tt(Pt(xt),{ref_key:"graphRef",ref:t,options:e,"on-node-click":s,"on-line-click":o},{"graph-plug":jt(()=>[Oi]),_:1},512)])]))}});const ji=Kt(Ii,[["__scopeId","data-v-356017b1"]]);export{ji as default};
