import{z as l,S as O,N as j}from"./index-a76d1c04.js";const{JUNCTION_POINT_STYLE:y}=j;console.log("JUNCTION_POINT_STYLE:",l);class D extends O{constructor(...r){super(...r)}createLinePath(r,c,n){let o=r.fromNode;o||(o={x:0,y:0,el:{offsetWidth:10,offsetHeight:10}});const e=r.toNode;n||(n=0);const N=c.lineDirection||this.options.layoutDirection||"h";console.log("createLinePath",N);let f=o.x,g=o.y,b=e.x,R=e.y;const t={x:0,y:0,rotate:0};if(Number.isNaN(f)||Number.isNaN(g))return console.log("error start node:",o.text,o.x,o.y),t.x=50,t.y=50,t.rotate=0,this.createReturnValue("M 0 0 L 100 100",t);if(Number.isNaN(b)||Number.isNaN(R))return console.log("error end point:",e.text,e.x,e.y),t.x=50,t.y=50,t.rotate=0,this.createReturnValue("M 0 0 L 100 100",t);let L=o.el.offsetWidth||o.width||60,$=o.el.offsetHeight||o.height||60;if(Number.isNaN(L)||Number.isNaN($))return console.log("error end point22:",e.text,e.x,e.y),t.x=50,t.y=50,t.rotate=0,this.createReturnValue("M 0 0 L 100 100",t);let P=e.el.offsetWidth||e.width||60,M=e.el.offsetHeight||e.height||60;if(Number.isNaN(P)||Number.isNaN(M))return console.log("error end point33:",e.text,e.x,e.y),t.x=50,t.y=50,t.rotate=0,this.createReturnValue("M 0 0 L 100 100",t);const p=[f,g,b,R,L,$,P,M,this.options.defaultNodeShape,!1,r.relations.length,n],m=[b,R,f,g,P,M,L,$,this.options.defaultNodeShape,!0,r.relations.length,n];let i,s,u=o.junctionPoint||this.options.defaultJunctionPoint;if(u||(u=y.border),u===y.border)i=l.getBorderPoint4MultiLine(...p),s=l.getBorderPoint4MultiLine(...m);else if(u===y.ltrb)i=l.getRectJoinPoint(...p),s=l.getRectJoinPoint(...m);else if(u===y.tb)i=l.getRectVJoinPoint(...p),s=l.getRectVJoinPoint(...m);else if(u===y.lr)i=l.getRectHJoinPoint(...p),s=l.getRectHJoinPoint(...m);else return this.createReturnValue("Unknown join point type:"+u,t);if(!i||!s)return this.createReturnValue("Can not create start and end!",t);const h=i.x,d=i.y,_=s.x,x=s.y;if(Number.isNaN(h)||Number.isNaN(d))return console.error("error start point:",o),t.x=50,t.y=50,t.rotate=0,this.createReturnValue("M 0 0 L 100 100",t);if(Number.isNaN(_)||Number.isNaN(x))return console.error("error end point:",e),t.x=50,t.y=50,t.rotate=0,this.createReturnValue("M 0 0 L 100 100",t);s.x-i.x,s.y-i.y;let T=s.x>i.x?1:-1;N==="v"&&(T=s.y>i.y?1:-1);let S="";const W=Math.floor(60/(r.relations.length+1)*(n+1))-30;let I=this.options.defaultPloyLineRadius||0;if(N==="v"){const a=T*33+W-I;S=`M ${h} ${d} v${a} L${_} ${x-a} v${a}`;const V=h,J=d+a,v=_,H=x-a;this.calcTextPosition(V,J,v,H,t)}else{const a=T*33+W-I;S=`M ${h} ${d} h${a} L ${_-a} ${x} h${a}`;const V=h+a,J=d,v=_-a,H=x;this.calcTextPosition(V,J,v,H,t)}return this.createReturnValue(S,t)}calcTextPosition(r,c,n,o,e){const N=n-r,f=o-c;e.rotate=l.getTextAngle(r,c,n,o),e.x=Math.round(r+N/2),e.y=Math.round(c+f/2),Number.isNaN(e.rotate)&&(e.rotate=0)}getTextTransform(r,c,n,o){if(Number.isNaN(c)||Number.isNaN(n))return"translate(0,0)";const e=r.lineShape===void 0?this.options.defaultLineShape:r.lineShape;return e===1||e===4?`translate(${c},${n})rotate(${o||0})`:`translate(${c},${n})`}}export{D as R};
