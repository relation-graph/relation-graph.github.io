import{r as He,a as Ae,j as xt}from"./index.7473cb17.js";import{u as Ft}from"./relation-graph.26f01d58.js";var Ie={exports:{}},le=typeof Reflect=="object"?Reflect:null,Ye=le&&typeof le.apply=="function"?le.apply:function(t,e,n){return Function.prototype.apply.call(t,e,n)},Se;le&&typeof le.ownKeys=="function"?Se=le.ownKeys:Object.getOwnPropertySymbols?Se=function(t){return Object.getOwnPropertyNames(t).concat(Object.getOwnPropertySymbols(t))}:Se=function(t){return Object.getOwnPropertyNames(t)};function Ut(i){console&&console.warn&&console.warn(i)}var tt=Number.isNaN||function(t){return t!==t};function A(){A.init.call(this)}Ie.exports=A;Ie.exports.once=It;A.EventEmitter=A;A.prototype._events=void 0;A.prototype._eventsCount=0;A.prototype._maxListeners=void 0;var Ve=10;function Be(i){if(typeof i!="function")throw new TypeError('The "listener" argument must be of type Function. Received type '+typeof i)}Object.defineProperty(A,"defaultMaxListeners",{enumerable:!0,get:function(){return Ve},set:function(i){if(typeof i!="number"||i<0||tt(i))throw new RangeError('The value of "defaultMaxListeners" is out of range. It must be a non-negative number. Received '+i+".");Ve=i}});A.init=function(){(this._events===void 0||this._events===Object.getPrototypeOf(this)._events)&&(this._events=Object.create(null),this._eventsCount=0),this._maxListeners=this._maxListeners||void 0};A.prototype.setMaxListeners=function(t){if(typeof t!="number"||t<0||tt(t))throw new RangeError('The value of "n" is out of range. It must be a non-negative number. Received '+t+".");return this._maxListeners=t,this};function nt(i){return i._maxListeners===void 0?A.defaultMaxListeners:i._maxListeners}A.prototype.getMaxListeners=function(){return nt(this)};A.prototype.emit=function(t){for(var e=[],n=1;n<arguments.length;n++)e.push(arguments[n]);var s=t==="error",o=this._events;if(o!==void 0)s=s&&o.error===void 0;else if(!s)return!1;if(s){var r;if(e.length>0&&(r=e[0]),r instanceof Error)throw r;var u=new Error("Unhandled error."+(r?" ("+r.message+")":""));throw u.context=r,u}var a=o[t];if(a===void 0)return!1;if(typeof a=="function")Ye(a,this,e);else for(var d=a.length,l=ut(a,d),n=0;n<d;++n)Ye(l[n],this,e);return!0};function it(i,t,e,n){var s,o,r;if(Be(e),o=i._events,o===void 0?(o=i._events=Object.create(null),i._eventsCount=0):(o.newListener!==void 0&&(i.emit("newListener",t,e.listener?e.listener:e),o=i._events),r=o[t]),r===void 0)r=o[t]=e,++i._eventsCount;else if(typeof r=="function"?r=o[t]=n?[e,r]:[r,e]:n?r.unshift(e):r.push(e),s=nt(i),s>0&&r.length>s&&!r.warned){r.warned=!0;var u=new Error("Possible EventEmitter memory leak detected. "+r.length+" "+String(t)+" listeners added. Use emitter.setMaxListeners() to increase limit");u.name="MaxListenersExceededWarning",u.emitter=i,u.type=t,u.count=r.length,Ut(u)}return i}A.prototype.addListener=function(t,e){return it(this,t,e,!1)};A.prototype.on=A.prototype.addListener;A.prototype.prependListener=function(t,e){return it(this,t,e,!0)};function Ot(){if(!this.fired)return this.target.removeListener(this.type,this.wrapFn),this.fired=!0,arguments.length===0?this.listener.call(this.target):this.listener.apply(this.target,arguments)}function rt(i,t,e){var n={fired:!1,wrapFn:void 0,target:i,type:t,listener:e},s=Ot.bind(n);return s.listener=e,n.wrapFn=s,s}A.prototype.once=function(t,e){return Be(e),this.on(t,rt(this,t,e)),this};A.prototype.prependOnceListener=function(t,e){return Be(e),this.prependListener(t,rt(this,t,e)),this};A.prototype.removeListener=function(t,e){var n,s,o,r,u;if(Be(e),s=this._events,s===void 0)return this;if(n=s[t],n===void 0)return this;if(n===e||n.listener===e)--this._eventsCount===0?this._events=Object.create(null):(delete s[t],s.removeListener&&this.emit("removeListener",t,n.listener||e));else if(typeof n!="function"){for(o=-1,r=n.length-1;r>=0;r--)if(n[r]===e||n[r].listener===e){u=n[r].listener,o=r;break}if(o<0)return this;o===0?n.shift():Rt(n,o),n.length===1&&(s[t]=n[0]),s.removeListener!==void 0&&this.emit("removeListener",t,u||e)}return this};A.prototype.off=A.prototype.removeListener;A.prototype.removeAllListeners=function(t){var e,n,s;if(n=this._events,n===void 0)return this;if(n.removeListener===void 0)return arguments.length===0?(this._events=Object.create(null),this._eventsCount=0):n[t]!==void 0&&(--this._eventsCount===0?this._events=Object.create(null):delete n[t]),this;if(arguments.length===0){var o=Object.keys(n),r;for(s=0;s<o.length;++s)r=o[s],r!=="removeListener"&&this.removeAllListeners(r);return this.removeAllListeners("removeListener"),this._events=Object.create(null),this._eventsCount=0,this}if(e=n[t],typeof e=="function")this.removeListener(t,e);else if(e!==void 0)for(s=e.length-1;s>=0;s--)this.removeListener(t,e[s]);return this};function ot(i,t,e){var n=i._events;if(n===void 0)return[];var s=n[t];return s===void 0?[]:typeof s=="function"?e?[s.listener||s]:[s]:e?Ct(s):ut(s,s.length)}A.prototype.listeners=function(t){return ot(this,t,!0)};A.prototype.rawListeners=function(t){return ot(this,t,!1)};A.listenerCount=function(i,t){return typeof i.listenerCount=="function"?i.listenerCount(t):st.call(i,t)};A.prototype.listenerCount=st;function st(i){var t=this._events;if(t!==void 0){var e=t[i];if(typeof e=="function")return 1;if(e!==void 0)return e.length}return 0}A.prototype.eventNames=function(){return this._eventsCount>0?Se(this._events):[]};function ut(i,t){for(var e=new Array(t),n=0;n<t;++n)e[n]=i[n];return e}function Rt(i,t){for(;t+1<i.length;t++)i[t]=i[t+1];i.pop()}function Ct(i){for(var t=new Array(i.length),e=0;e<t.length;++e)t[e]=i[e].listener||i[e];return t}function It(i,t){return new Promise(function(e,n){function s(r){i.removeListener(t,o),n(r)}function o(){typeof i.removeListener=="function"&&i.removeListener("error",s),e([].slice.call(arguments))}at(i,t,o,{once:!0}),t!=="error"&&jt(i,s,{once:!0})})}function jt(i,t,e){typeof i.on=="function"&&at(i,"error",t,e)}function at(i,t,e,n){if(typeof i.on=="function")n.once?i.once(t,e):i.on(t,e);else if(typeof i.addEventListener=="function")i.addEventListener(t,function s(o){n.once&&i.removeEventListener(t,s),e(o)});else throw new TypeError('The "emitter" argument must be of type EventEmitter. Received type '+typeof i)}function Q(i){if(typeof i!="function")throw new Error("obliterator/iterator: expecting a function!");this.next=i}typeof Symbol<"u"&&(Q.prototype[Symbol.iterator]=function(){return this});Q.of=function(){var i=arguments,t=i.length,e=0;return new Q(function(){return e>=t?{done:!0}:{done:!1,value:i[e++]}})};Q.empty=function(){var i=new Q(function(){return{done:!0}});return i};Q.fromSequence=function(i){var t=0,e=i.length;return new Q(function(){return t>=e?{done:!0}:{done:!1,value:i[t++]}})};Q.is=function(i){return i instanceof Q?!0:typeof i=="object"&&i!==null&&typeof i.next=="function"};var P=Q,je={};je.ARRAY_BUFFER_SUPPORT=typeof ArrayBuffer<"u";je.SYMBOL_SUPPORT=typeof Symbol<"u";var Tt=P,dt=je,zt=dt.ARRAY_BUFFER_SUPPORT,Pt=dt.SYMBOL_SUPPORT;function Wt(i){return typeof i=="string"||Array.isArray(i)||zt&&ArrayBuffer.isView(i)?Tt.fromSequence(i):typeof i!="object"||i===null?null:Pt&&typeof i[Symbol.iterator]=="function"?i[Symbol.iterator]():typeof i.next=="function"?i:null}var ht=function(t){var e=Wt(t);if(!e)throw new Error("obliterator: target is not iterable nor a valid iterator.");return e},Kt=ht,ct=function(t,e){for(var n=arguments.length>1?e:1/0,s=n!==1/0?new Array(n):[],o,r=0,u=Kt(t);;){if(r===n)return s;if(o=u.next(),o.done)return r!==e&&(s.length=r),s;s[r++]=o.value}},Ht=P,Yt=ht,te=function(){var t=arguments,e=null,n=-1;return new Ht(function(){var o=null;do{if(e===null){if(n++,n>=t.length)return{done:!0};e=Yt(t[n])}if(o=e.next(),o.done===!0){e=null;continue}break}while(!0);return o})};function Vt(){const i=arguments[0];for(let t=1,e=arguments.length;t<e;t++)if(!!arguments[t])for(const n in arguments[t])i[n]=arguments[t][n];return i}let O=Vt;typeof Object.assign=="function"&&(O=Object.assign);function Y(i,t,e,n){const s=i._nodes.get(t);let o=null;return s&&(n==="mixed"?o=s.out&&s.out[e]||s.undirected&&s.undirected[e]:n==="directed"?o=s.out&&s.out[e]:o=s.undirected&&s.undirected[e]),o}function C(i){return typeof i=="object"&&i!==null}function ft(i){let t;for(t in i)return!1;return!0}function K(i,t,e){Object.defineProperty(i,t,{enumerable:!1,configurable:!1,writable:!0,value:e})}function V(i,t,e){const n={enumerable:!0,configurable:!0};typeof e=="function"?n.get=e:(n.value=e,n.writable=!1),Object.defineProperty(i,t,n)}function Je(i){return!(!C(i)||i.attributes&&!Array.isArray(i.attributes))}function Jt(){let i=Math.floor(Math.random()*256)&255;return()=>i++}class Te extends Error{constructor(t){super(),this.name="GraphError",this.message=t}}class g extends Te{constructor(t){super(t),this.name="InvalidArgumentsGraphError",typeof Error.captureStackTrace=="function"&&Error.captureStackTrace(this,g.prototype.constructor)}}class p extends Te{constructor(t){super(t),this.name="NotFoundGraphError",typeof Error.captureStackTrace=="function"&&Error.captureStackTrace(this,p.prototype.constructor)}}class w extends Te{constructor(t){super(t),this.name="UsageGraphError",typeof Error.captureStackTrace=="function"&&Error.captureStackTrace(this,w.prototype.constructor)}}function lt(i,t){this.key=i,this.attributes=t,this.clear()}lt.prototype.clear=function(){this.inDegree=0,this.outDegree=0,this.undirectedDegree=0,this.undirectedLoops=0,this.directedLoops=0,this.in={},this.out={},this.undirected={}};function pt(i,t){this.key=i,this.attributes=t,this.clear()}pt.prototype.clear=function(){this.inDegree=0,this.outDegree=0,this.directedLoops=0,this.in={},this.out={}};function gt(i,t){this.key=i,this.attributes=t,this.clear()}gt.prototype.clear=function(){this.undirectedDegree=0,this.undirectedLoops=0,this.undirected={}};function pe(i,t,e,n,s){this.key=t,this.attributes=s,this.undirected=i,this.source=e,this.target=n}pe.prototype.attach=function(){let i="out",t="in";this.undirected&&(i=t="undirected");const e=this.source.key,n=this.target.key;this.source[i][n]=this,!(this.undirected&&e===n)&&(this.target[t][e]=this)};pe.prototype.attachMulti=function(){let i="out",t="in";const e=this.source.key,n=this.target.key;this.undirected&&(i=t="undirected");const s=this.source[i],o=s[n];if(typeof o>"u"){s[n]=this,this.undirected&&e===n||(this.target[t][e]=this);return}o.previous=this,this.next=o,s[n]=this,this.target[t][e]=this};pe.prototype.detach=function(){const i=this.source.key,t=this.target.key;let e="out",n="in";this.undirected&&(e=n="undirected"),delete this.source[e][t],delete this.target[n][i]};pe.prototype.detachMulti=function(){const i=this.source.key,t=this.target.key;let e="out",n="in";this.undirected&&(e=n="undirected"),this.previous===void 0?this.next===void 0?(delete this.source[e][t],delete this.target[n][i]):(this.next.previous=void 0,this.source[e][t]=this.next,this.target[n][i]=this.next):(this.previous.next=this.next,this.next!==void 0&&(this.next.previous=this.previous))};const yt=0,wt=1,qt=2,mt=3;function ne(i,t,e,n,s,o,r){let u,a,d,l;if(n=""+n,e===yt){if(u=i._nodes.get(n),!u)throw new p(`Graph.${t}: could not find the "${n}" node in the graph.`);d=s,l=o}else if(e===mt){if(s=""+s,a=i._edges.get(s),!a)throw new p(`Graph.${t}: could not find the "${s}" edge in the graph.`);const c=a.source.key,h=a.target.key;if(n===c)u=a.target;else if(n===h)u=a.source;else throw new p(`Graph.${t}: the "${n}" node is not attached to the "${s}" edge (${c}, ${h}).`);d=o,l=r}else{if(a=i._edges.get(n),!a)throw new p(`Graph.${t}: could not find the "${n}" edge in the graph.`);e===wt?u=a.source:u=a.target,d=s,l=o}return[u,d,l]}function Zt(i,t,e){i.prototype[t]=function(n,s,o){const[r,u]=ne(this,t,e,n,s,o);return r.attributes[u]}}function Qt(i,t,e){i.prototype[t]=function(n,s){const[o]=ne(this,t,e,n,s);return o.attributes}}function Xt(i,t,e){i.prototype[t]=function(n,s,o){const[r,u]=ne(this,t,e,n,s,o);return r.attributes.hasOwnProperty(u)}}function Mt(i,t,e){i.prototype[t]=function(n,s,o,r){const[u,a,d]=ne(this,t,e,n,s,o,r);return u.attributes[a]=d,this.emit("nodeAttributesUpdated",{key:u.key,type:"set",attributes:u.attributes,name:a}),this}}function en(i,t,e){i.prototype[t]=function(n,s,o,r){const[u,a,d]=ne(this,t,e,n,s,o,r);if(typeof d!="function")throw new g(`Graph.${t}: updater should be a function.`);const l=u.attributes,c=d(l[a]);return l[a]=c,this.emit("nodeAttributesUpdated",{key:u.key,type:"set",attributes:u.attributes,name:a}),this}}function tn(i,t,e){i.prototype[t]=function(n,s,o){const[r,u]=ne(this,t,e,n,s,o);return delete r.attributes[u],this.emit("nodeAttributesUpdated",{key:r.key,type:"remove",attributes:r.attributes,name:u}),this}}function nn(i,t,e){i.prototype[t]=function(n,s,o){const[r,u]=ne(this,t,e,n,s,o);if(!C(u))throw new g(`Graph.${t}: provided attributes are not a plain object.`);return r.attributes=u,this.emit("nodeAttributesUpdated",{key:r.key,type:"replace",attributes:r.attributes}),this}}function rn(i,t,e){i.prototype[t]=function(n,s,o){const[r,u]=ne(this,t,e,n,s,o);if(!C(u))throw new g(`Graph.${t}: provided attributes are not a plain object.`);return O(r.attributes,u),this.emit("nodeAttributesUpdated",{key:r.key,type:"merge",attributes:r.attributes,data:u}),this}}function on(i,t,e){i.prototype[t]=function(n,s,o){const[r,u]=ne(this,t,e,n,s,o);if(typeof u!="function")throw new g(`Graph.${t}: provided updater is not a function.`);return r.attributes=u(r.attributes),this.emit("nodeAttributesUpdated",{key:r.key,type:"update",attributes:r.attributes}),this}}const sn=[{name:i=>`get${i}Attribute`,attacher:Zt},{name:i=>`get${i}Attributes`,attacher:Qt},{name:i=>`has${i}Attribute`,attacher:Xt},{name:i=>`set${i}Attribute`,attacher:Mt},{name:i=>`update${i}Attribute`,attacher:en},{name:i=>`remove${i}Attribute`,attacher:tn},{name:i=>`replace${i}Attributes`,attacher:nn},{name:i=>`merge${i}Attributes`,attacher:rn},{name:i=>`update${i}Attributes`,attacher:on}];function un(i){sn.forEach(function({name:t,attacher:e}){e(i,t("Node"),yt),e(i,t("Source"),wt),e(i,t("Target"),qt),e(i,t("Opposite"),mt)})}function an(i,t,e){i.prototype[t]=function(n,s){let o;if(this.type!=="mixed"&&e!=="mixed"&&e!==this.type)throw new w(`Graph.${t}: cannot find this type of edges in your ${this.type} graph.`);if(arguments.length>2){if(this.multi)throw new w(`Graph.${t}: cannot use a {source,target} combo when asking about an edge's attributes in a MultiGraph since we cannot infer the one you want information about.`);const r=""+n,u=""+s;if(s=arguments[2],o=Y(this,r,u,e),!o)throw new p(`Graph.${t}: could not find an edge for the given path ("${r}" - "${u}").`)}else{if(e!=="mixed")throw new w(`Graph.${t}: calling this method with only a key (vs. a source and target) does not make sense since an edge with this key could have the other type.`);if(n=""+n,o=this._edges.get(n),!o)throw new p(`Graph.${t}: could not find the "${n}" edge in the graph.`)}return o.attributes[s]}}function dn(i,t,e){i.prototype[t]=function(n){let s;if(this.type!=="mixed"&&e!=="mixed"&&e!==this.type)throw new w(`Graph.${t}: cannot find this type of edges in your ${this.type} graph.`);if(arguments.length>1){if(this.multi)throw new w(`Graph.${t}: cannot use a {source,target} combo when asking about an edge's attributes in a MultiGraph since we cannot infer the one you want information about.`);const o=""+n,r=""+arguments[1];if(s=Y(this,o,r,e),!s)throw new p(`Graph.${t}: could not find an edge for the given path ("${o}" - "${r}").`)}else{if(e!=="mixed")throw new w(`Graph.${t}: calling this method with only a key (vs. a source and target) does not make sense since an edge with this key could have the other type.`);if(n=""+n,s=this._edges.get(n),!s)throw new p(`Graph.${t}: could not find the "${n}" edge in the graph.`)}return s.attributes}}function hn(i,t,e){i.prototype[t]=function(n,s){let o;if(this.type!=="mixed"&&e!=="mixed"&&e!==this.type)throw new w(`Graph.${t}: cannot find this type of edges in your ${this.type} graph.`);if(arguments.length>2){if(this.multi)throw new w(`Graph.${t}: cannot use a {source,target} combo when asking about an edge's attributes in a MultiGraph since we cannot infer the one you want information about.`);const r=""+n,u=""+s;if(s=arguments[2],o=Y(this,r,u,e),!o)throw new p(`Graph.${t}: could not find an edge for the given path ("${r}" - "${u}").`)}else{if(e!=="mixed")throw new w(`Graph.${t}: calling this method with only a key (vs. a source and target) does not make sense since an edge with this key could have the other type.`);if(n=""+n,o=this._edges.get(n),!o)throw new p(`Graph.${t}: could not find the "${n}" edge in the graph.`)}return o.attributes.hasOwnProperty(s)}}function cn(i,t,e){i.prototype[t]=function(n,s,o){let r;if(this.type!=="mixed"&&e!=="mixed"&&e!==this.type)throw new w(`Graph.${t}: cannot find this type of edges in your ${this.type} graph.`);if(arguments.length>3){if(this.multi)throw new w(`Graph.${t}: cannot use a {source,target} combo when asking about an edge's attributes in a MultiGraph since we cannot infer the one you want information about.`);const u=""+n,a=""+s;if(s=arguments[2],o=arguments[3],r=Y(this,u,a,e),!r)throw new p(`Graph.${t}: could not find an edge for the given path ("${u}" - "${a}").`)}else{if(e!=="mixed")throw new w(`Graph.${t}: calling this method with only a key (vs. a source and target) does not make sense since an edge with this key could have the other type.`);if(n=""+n,r=this._edges.get(n),!r)throw new p(`Graph.${t}: could not find the "${n}" edge in the graph.`)}return r.attributes[s]=o,this.emit("edgeAttributesUpdated",{key:r.key,type:"set",attributes:r.attributes,name:s}),this}}function fn(i,t,e){i.prototype[t]=function(n,s,o){let r;if(this.type!=="mixed"&&e!=="mixed"&&e!==this.type)throw new w(`Graph.${t}: cannot find this type of edges in your ${this.type} graph.`);if(arguments.length>3){if(this.multi)throw new w(`Graph.${t}: cannot use a {source,target} combo when asking about an edge's attributes in a MultiGraph since we cannot infer the one you want information about.`);const u=""+n,a=""+s;if(s=arguments[2],o=arguments[3],r=Y(this,u,a,e),!r)throw new p(`Graph.${t}: could not find an edge for the given path ("${u}" - "${a}").`)}else{if(e!=="mixed")throw new w(`Graph.${t}: calling this method with only a key (vs. a source and target) does not make sense since an edge with this key could have the other type.`);if(n=""+n,r=this._edges.get(n),!r)throw new p(`Graph.${t}: could not find the "${n}" edge in the graph.`)}if(typeof o!="function")throw new g(`Graph.${t}: updater should be a function.`);return r.attributes[s]=o(r.attributes[s]),this.emit("edgeAttributesUpdated",{key:r.key,type:"set",attributes:r.attributes,name:s}),this}}function ln(i,t,e){i.prototype[t]=function(n,s){let o;if(this.type!=="mixed"&&e!=="mixed"&&e!==this.type)throw new w(`Graph.${t}: cannot find this type of edges in your ${this.type} graph.`);if(arguments.length>2){if(this.multi)throw new w(`Graph.${t}: cannot use a {source,target} combo when asking about an edge's attributes in a MultiGraph since we cannot infer the one you want information about.`);const r=""+n,u=""+s;if(s=arguments[2],o=Y(this,r,u,e),!o)throw new p(`Graph.${t}: could not find an edge for the given path ("${r}" - "${u}").`)}else{if(e!=="mixed")throw new w(`Graph.${t}: calling this method with only a key (vs. a source and target) does not make sense since an edge with this key could have the other type.`);if(n=""+n,o=this._edges.get(n),!o)throw new p(`Graph.${t}: could not find the "${n}" edge in the graph.`)}return delete o.attributes[s],this.emit("edgeAttributesUpdated",{key:o.key,type:"remove",attributes:o.attributes,name:s}),this}}function pn(i,t,e){i.prototype[t]=function(n,s){let o;if(this.type!=="mixed"&&e!=="mixed"&&e!==this.type)throw new w(`Graph.${t}: cannot find this type of edges in your ${this.type} graph.`);if(arguments.length>2){if(this.multi)throw new w(`Graph.${t}: cannot use a {source,target} combo when asking about an edge's attributes in a MultiGraph since we cannot infer the one you want information about.`);const r=""+n,u=""+s;if(s=arguments[2],o=Y(this,r,u,e),!o)throw new p(`Graph.${t}: could not find an edge for the given path ("${r}" - "${u}").`)}else{if(e!=="mixed")throw new w(`Graph.${t}: calling this method with only a key (vs. a source and target) does not make sense since an edge with this key could have the other type.`);if(n=""+n,o=this._edges.get(n),!o)throw new p(`Graph.${t}: could not find the "${n}" edge in the graph.`)}if(!C(s))throw new g(`Graph.${t}: provided attributes are not a plain object.`);return o.attributes=s,this.emit("edgeAttributesUpdated",{key:o.key,type:"replace",attributes:o.attributes}),this}}function gn(i,t,e){i.prototype[t]=function(n,s){let o;if(this.type!=="mixed"&&e!=="mixed"&&e!==this.type)throw new w(`Graph.${t}: cannot find this type of edges in your ${this.type} graph.`);if(arguments.length>2){if(this.multi)throw new w(`Graph.${t}: cannot use a {source,target} combo when asking about an edge's attributes in a MultiGraph since we cannot infer the one you want information about.`);const r=""+n,u=""+s;if(s=arguments[2],o=Y(this,r,u,e),!o)throw new p(`Graph.${t}: could not find an edge for the given path ("${r}" - "${u}").`)}else{if(e!=="mixed")throw new w(`Graph.${t}: calling this method with only a key (vs. a source and target) does not make sense since an edge with this key could have the other type.`);if(n=""+n,o=this._edges.get(n),!o)throw new p(`Graph.${t}: could not find the "${n}" edge in the graph.`)}if(!C(s))throw new g(`Graph.${t}: provided attributes are not a plain object.`);return O(o.attributes,s),this.emit("edgeAttributesUpdated",{key:o.key,type:"merge",attributes:o.attributes,data:s}),this}}function yn(i,t,e){i.prototype[t]=function(n,s){let o;if(this.type!=="mixed"&&e!=="mixed"&&e!==this.type)throw new w(`Graph.${t}: cannot find this type of edges in your ${this.type} graph.`);if(arguments.length>2){if(this.multi)throw new w(`Graph.${t}: cannot use a {source,target} combo when asking about an edge's attributes in a MultiGraph since we cannot infer the one you want information about.`);const r=""+n,u=""+s;if(s=arguments[2],o=Y(this,r,u,e),!o)throw new p(`Graph.${t}: could not find an edge for the given path ("${r}" - "${u}").`)}else{if(e!=="mixed")throw new w(`Graph.${t}: calling this method with only a key (vs. a source and target) does not make sense since an edge with this key could have the other type.`);if(n=""+n,o=this._edges.get(n),!o)throw new p(`Graph.${t}: could not find the "${n}" edge in the graph.`)}if(typeof s!="function")throw new g(`Graph.${t}: provided updater is not a function.`);return o.attributes=s(o.attributes),this.emit("edgeAttributesUpdated",{key:o.key,type:"update",attributes:o.attributes}),this}}const wn=[{name:i=>`get${i}Attribute`,attacher:an},{name:i=>`get${i}Attributes`,attacher:dn},{name:i=>`has${i}Attribute`,attacher:hn},{name:i=>`set${i}Attribute`,attacher:cn},{name:i=>`update${i}Attribute`,attacher:fn},{name:i=>`remove${i}Attribute`,attacher:ln},{name:i=>`replace${i}Attributes`,attacher:pn},{name:i=>`merge${i}Attributes`,attacher:gn},{name:i=>`update${i}Attributes`,attacher:yn}];function mn(i){wn.forEach(function({name:t,attacher:e}){e(i,t("Edge"),"mixed"),e(i,t("DirectedEdge"),"directed"),e(i,t("UndirectedEdge"),"undirected")})}const bn=[{name:"edges",type:"mixed"},{name:"inEdges",type:"directed",direction:"in"},{name:"outEdges",type:"directed",direction:"out"},{name:"inboundEdges",type:"mixed",direction:"in"},{name:"outboundEdges",type:"mixed",direction:"out"},{name:"directedEdges",type:"directed"},{name:"undirectedEdges",type:"undirected"}];function En(i,t,e,n){let s=!1;for(const o in t){if(o===n)continue;const r=t[o];if(s=e(r.key,r.attributes,r.source.key,r.target.key,r.source.attributes,r.target.attributes,r.undirected),i&&s)return r.key}}function vn(i,t,e,n){let s,o,r,u=!1;for(const a in t)if(a!==n){s=t[a];do{if(o=s.source,r=s.target,u=e(s.key,s.attributes,o.key,r.key,o.attributes,r.attributes,s.undirected),i&&u)return s.key;s=s.next}while(s!==void 0)}}function Oe(i,t){const e=Object.keys(i),n=e.length;let s,o=0;return new P(function(){do if(s)s=s.next;else{if(o>=n)return{done:!0};const u=e[o++];if(u===t){s=void 0;continue}s=i[u]}while(!s);return{done:!1,value:{edge:s.key,attributes:s.attributes,source:s.source.key,target:s.target.key,sourceAttributes:s.source.attributes,targetAttributes:s.target.attributes,undirected:s.undirected}}})}function _n(i,t,e,n){const s=t[e];if(!s)return;const o=s.source,r=s.target;if(n(s.key,s.attributes,o.key,r.key,o.attributes,r.attributes,s.undirected)&&i)return s.key}function $n(i,t,e,n){let s=t[e];if(!s)return;let o=!1;do{if(o=n(s.key,s.attributes,s.source.key,s.target.key,s.source.attributes,s.target.attributes,s.undirected),i&&o)return s.key;s=s.next}while(s!==void 0)}function Re(i,t){let e=i[t];return e.next!==void 0?new P(function(){if(!e)return{done:!0};const n={edge:e.key,attributes:e.attributes,source:e.source.key,target:e.target.key,sourceAttributes:e.source.attributes,targetAttributes:e.target.attributes,undirected:e.undirected};return e=e.next,{done:!1,value:n}}):P.of({edge:e.key,attributes:e.attributes,source:e.source.key,target:e.target.key,sourceAttributes:e.source.attributes,targetAttributes:e.target.attributes,undirected:e.undirected})}function Gn(i,t){if(i.size===0)return[];if(t==="mixed"||t===i.type)return typeof Array.from=="function"?Array.from(i._edges.keys()):ct(i._edges.keys(),i._edges.size);const e=t==="undirected"?i.undirectedSize:i.directedSize,n=new Array(e),s=t==="undirected",o=i._edges.values();let r=0,u,a;for(;u=o.next(),u.done!==!0;)a=u.value,a.undirected===s&&(n[r++]=a.key);return n}function bt(i,t,e,n){if(t.size===0)return;const s=e!=="mixed"&&e!==t.type,o=e==="undirected";let r,u,a=!1;const d=t._edges.values();for(;r=d.next(),r.done!==!0;){if(u=r.value,s&&u.undirected!==o)continue;const{key:l,attributes:c,source:h,target:y}=u;if(a=n(l,c,h.key,y.key,h.attributes,y.attributes,u.undirected),i&&a)return l}}function Dn(i,t){if(i.size===0)return P.empty();const e=t!=="mixed"&&t!==i.type,n=t==="undirected",s=i._edges.values();return new P(function(){let r,u;for(;;){if(r=s.next(),r.done)return r;if(u=r.value,!(e&&u.undirected!==n))break}return{value:{edge:u.key,attributes:u.attributes,source:u.source.key,target:u.target.key,sourceAttributes:u.source.attributes,targetAttributes:u.target.attributes,undirected:u.undirected},done:!1}})}function ze(i,t,e,n,s,o){const r=t?vn:En;let u;if(e!=="undirected"&&(n!=="out"&&(u=r(i,s.in,o),i&&u)||n!=="in"&&(u=r(i,s.out,o,n?void 0:s.key),i&&u))||e!=="directed"&&(u=r(i,s.undirected,o),i&&u))return u}function kn(i,t,e,n){const s=[];return ze(!1,i,t,e,n,function(o){s.push(o)}),s}function An(i,t,e){let n=P.empty();return i!=="undirected"&&(t!=="out"&&typeof e.in<"u"&&(n=te(n,Oe(e.in))),t!=="in"&&typeof e.out<"u"&&(n=te(n,Oe(e.out,t?void 0:e.key)))),i!=="directed"&&typeof e.undirected<"u"&&(n=te(n,Oe(e.undirected))),n}function Pe(i,t,e,n,s,o,r){const u=e?$n:_n;let a;if(t!=="undirected"&&(typeof s.in<"u"&&n!=="out"&&(a=u(i,s.in,o,r),i&&a)||typeof s.out<"u"&&n!=="in"&&(n||s.key!==o)&&(a=u(i,s.out,o,r),i&&a))||t!=="directed"&&typeof s.undirected<"u"&&(a=u(i,s.undirected,o,r),i&&a))return a}function Nn(i,t,e,n,s){const o=[];return Pe(!1,i,t,e,n,s,function(r){o.push(r)}),o}function Ln(i,t,e,n){let s=P.empty();return i!=="undirected"&&(typeof e.in<"u"&&t!=="out"&&n in e.in&&(s=te(s,Re(e.in,n))),typeof e.out<"u"&&t!=="in"&&n in e.out&&(t||e.key!==n)&&(s=te(s,Re(e.out,n)))),i!=="directed"&&typeof e.undirected<"u"&&n in e.undirected&&(s=te(s,Re(e.undirected,n))),s}function Sn(i,t){const{name:e,type:n,direction:s}=t;i.prototype[e]=function(o,r){if(n!=="mixed"&&this.type!=="mixed"&&n!==this.type)return[];if(!arguments.length)return Gn(this,n);if(arguments.length===1){o=""+o;const u=this._nodes.get(o);if(typeof u>"u")throw new p(`Graph.${e}: could not find the "${o}" node in the graph.`);return kn(this.multi,n==="mixed"?this.type:n,s,u)}if(arguments.length===2){o=""+o,r=""+r;const u=this._nodes.get(o);if(!u)throw new p(`Graph.${e}:  could not find the "${o}" source node in the graph.`);if(!this._nodes.has(r))throw new p(`Graph.${e}:  could not find the "${r}" target node in the graph.`);return Nn(n,this.multi,s,u,r)}throw new g(`Graph.${e}: too many arguments (expecting 0, 1 or 2 and got ${arguments.length}).`)}}function Bn(i,t){const{name:e,type:n,direction:s}=t,o="forEach"+e[0].toUpperCase()+e.slice(1,-1);i.prototype[o]=function(d,l,c){if(!(n!=="mixed"&&this.type!=="mixed"&&n!==this.type)){if(arguments.length===1)return c=d,bt(!1,this,n,c);if(arguments.length===2){d=""+d,c=l;const h=this._nodes.get(d);if(typeof h>"u")throw new p(`Graph.${o}: could not find the "${d}" node in the graph.`);return ze(!1,this.multi,n==="mixed"?this.type:n,s,h,c)}if(arguments.length===3){d=""+d,l=""+l;const h=this._nodes.get(d);if(!h)throw new p(`Graph.${o}:  could not find the "${d}" source node in the graph.`);if(!this._nodes.has(l))throw new p(`Graph.${o}:  could not find the "${l}" target node in the graph.`);return Pe(!1,n,this.multi,s,h,l,c)}throw new g(`Graph.${o}: too many arguments (expecting 1, 2 or 3 and got ${arguments.length}).`)}};const r="map"+e[0].toUpperCase()+e.slice(1);i.prototype[r]=function(){const d=Array.prototype.slice.call(arguments),l=d.pop();let c;if(d.length===0){let h=0;n!=="directed"&&(h+=this.undirectedSize),n!=="undirected"&&(h+=this.directedSize),c=new Array(h);let y=0;d.push((E,L,S,F,j,k,v)=>{c[y++]=l(E,L,S,F,j,k,v)})}else c=[],d.push((h,y,E,L,S,F,j)=>{c.push(l(h,y,E,L,S,F,j))});return this[o].apply(this,d),c};const u="filter"+e[0].toUpperCase()+e.slice(1);i.prototype[u]=function(){const d=Array.prototype.slice.call(arguments),l=d.pop(),c=[];return d.push((h,y,E,L,S,F,j)=>{l(h,y,E,L,S,F,j)&&c.push(h)}),this[o].apply(this,d),c};const a="reduce"+e[0].toUpperCase()+e.slice(1);i.prototype[a]=function(){let d=Array.prototype.slice.call(arguments);if(d.length<2||d.length>4)throw new g(`Graph.${a}: invalid number of arguments (expecting 2, 3 or 4 and got ${d.length}).`);if(typeof d[d.length-1]=="function"&&typeof d[d.length-2]!="function")throw new g(`Graph.${a}: missing initial value. You must provide it because the callback takes more than one argument and we cannot infer the initial value from the first iteration, as you could with a simple array.`);let l,c;d.length===2?(l=d[0],c=d[1],d=[]):d.length===3?(l=d[1],c=d[2],d=[d[0]]):d.length===4&&(l=d[2],c=d[3],d=[d[0],d[1]]);let h=c;return d.push((y,E,L,S,F,j,k)=>{h=l(h,y,E,L,S,F,j,k)}),this[o].apply(this,d),h}}function xn(i,t){const{name:e,type:n,direction:s}=t,o="find"+e[0].toUpperCase()+e.slice(1,-1);i.prototype[o]=function(a,d,l){if(n!=="mixed"&&this.type!=="mixed"&&n!==this.type)return!1;if(arguments.length===1)return l=a,bt(!0,this,n,l);if(arguments.length===2){a=""+a,l=d;const c=this._nodes.get(a);if(typeof c>"u")throw new p(`Graph.${o}: could not find the "${a}" node in the graph.`);return ze(!0,this.multi,n==="mixed"?this.type:n,s,c,l)}if(arguments.length===3){a=""+a,d=""+d;const c=this._nodes.get(a);if(!c)throw new p(`Graph.${o}:  could not find the "${a}" source node in the graph.`);if(!this._nodes.has(d))throw new p(`Graph.${o}:  could not find the "${d}" target node in the graph.`);return Pe(!0,n,this.multi,s,c,d,l)}throw new g(`Graph.${o}: too many arguments (expecting 1, 2 or 3 and got ${arguments.length}).`)};const r="some"+e[0].toUpperCase()+e.slice(1,-1);i.prototype[r]=function(){const a=Array.prototype.slice.call(arguments),d=a.pop();return a.push((c,h,y,E,L,S,F)=>d(c,h,y,E,L,S,F)),!!this[o].apply(this,a)};const u="every"+e[0].toUpperCase()+e.slice(1,-1);i.prototype[u]=function(){const a=Array.prototype.slice.call(arguments),d=a.pop();return a.push((c,h,y,E,L,S,F)=>!d(c,h,y,E,L,S,F)),!this[o].apply(this,a)}}function Fn(i,t){const{name:e,type:n,direction:s}=t,o=e.slice(0,-1)+"Entries";i.prototype[o]=function(r,u){if(n!=="mixed"&&this.type!=="mixed"&&n!==this.type)return P.empty();if(!arguments.length)return Dn(this,n);if(arguments.length===1){r=""+r;const a=this._nodes.get(r);if(!a)throw new p(`Graph.${o}: could not find the "${r}" node in the graph.`);return An(n,s,a)}if(arguments.length===2){r=""+r,u=""+u;const a=this._nodes.get(r);if(!a)throw new p(`Graph.${o}:  could not find the "${r}" source node in the graph.`);if(!this._nodes.has(u))throw new p(`Graph.${o}:  could not find the "${u}" target node in the graph.`);return Ln(n,s,a,u)}throw new g(`Graph.${o}: too many arguments (expecting 0, 1 or 2 and got ${arguments.length}).`)}}function Un(i){bn.forEach(t=>{Sn(i,t),Bn(i,t),xn(i,t),Fn(i,t)})}const On=[{name:"neighbors",type:"mixed"},{name:"inNeighbors",type:"directed",direction:"in"},{name:"outNeighbors",type:"directed",direction:"out"},{name:"inboundNeighbors",type:"mixed",direction:"in"},{name:"outboundNeighbors",type:"mixed",direction:"out"},{name:"directedNeighbors",type:"directed"},{name:"undirectedNeighbors",type:"undirected"}];function xe(){this.A=null,this.B=null}xe.prototype.wrap=function(i){this.A===null?this.A=i:this.B===null&&(this.B=i)};xe.prototype.has=function(i){return this.A!==null&&i in this.A||this.B!==null&&i in this.B};function we(i,t,e,n,s){for(const o in n){const r=n[o],u=r.source,a=r.target,d=u===e?a:u;if(t&&t.has(d.key))continue;const l=s(d.key,d.attributes);if(i&&l)return d.key}}function We(i,t,e,n,s){if(t!=="mixed"){if(t==="undirected")return we(i,null,n,n.undirected,s);if(typeof e=="string")return we(i,null,n,n[e],s)}const o=new xe;let r;if(t!=="undirected"){if(e!=="out"){if(r=we(i,null,n,n.in,s),i&&r)return r;o.wrap(n.in)}if(e!=="in"){if(r=we(i,o,n,n.out,s),i&&r)return r;o.wrap(n.out)}}if(t!=="directed"&&(r=we(i,o,n,n.undirected,s),i&&r))return r}function Rn(i,t,e){if(i!=="mixed"){if(i==="undirected")return Object.keys(e.undirected);if(typeof t=="string")return Object.keys(e[t])}const n=[];return We(!1,i,t,e,function(s){n.push(s)}),n}function me(i,t,e){const n=Object.keys(e),s=n.length;let o=0;return new P(function(){let u=null;do{if(o>=s)return i&&i.wrap(e),{done:!0};const a=e[n[o++]],d=a.source,l=a.target;if(u=d===t?l:d,i&&i.has(u.key)){u=null;continue}}while(u===null);return{done:!1,value:{neighbor:u.key,attributes:u.attributes}}})}function Cn(i,t,e){if(i!=="mixed"){if(i==="undirected")return me(null,e,e.undirected);if(typeof t=="string")return me(null,e,e[t])}let n=P.empty();const s=new xe;return i!=="undirected"&&(t!=="out"&&(n=te(n,me(s,e,e.in))),t!=="in"&&(n=te(n,me(s,e,e.out)))),i!=="directed"&&(n=te(n,me(s,e,e.undirected))),n}function In(i,t){const{name:e,type:n,direction:s}=t;i.prototype[e]=function(o){if(n!=="mixed"&&this.type!=="mixed"&&n!==this.type)return[];o=""+o;const r=this._nodes.get(o);if(typeof r>"u")throw new p(`Graph.${e}: could not find the "${o}" node in the graph.`);return Rn(n==="mixed"?this.type:n,s,r)}}function jn(i,t){const{name:e,type:n,direction:s}=t,o="forEach"+e[0].toUpperCase()+e.slice(1,-1);i.prototype[o]=function(d,l){if(n!=="mixed"&&this.type!=="mixed"&&n!==this.type)return;d=""+d;const c=this._nodes.get(d);if(typeof c>"u")throw new p(`Graph.${o}: could not find the "${d}" node in the graph.`);We(!1,n==="mixed"?this.type:n,s,c,l)};const r="map"+e[0].toUpperCase()+e.slice(1);i.prototype[r]=function(d,l){const c=[];return this[o](d,(h,y)=>{c.push(l(h,y))}),c};const u="filter"+e[0].toUpperCase()+e.slice(1);i.prototype[u]=function(d,l){const c=[];return this[o](d,(h,y)=>{l(h,y)&&c.push(h)}),c};const a="reduce"+e[0].toUpperCase()+e.slice(1);i.prototype[a]=function(d,l,c){if(arguments.length<3)throw new g(`Graph.${a}: missing initial value. You must provide it because the callback takes more than one argument and we cannot infer the initial value from the first iteration, as you could with a simple array.`);let h=c;return this[o](d,(y,E)=>{h=l(h,y,E)}),h}}function Tn(i,t){const{name:e,type:n,direction:s}=t,o=e[0].toUpperCase()+e.slice(1,-1),r="find"+o;i.prototype[r]=function(d,l){if(n!=="mixed"&&this.type!=="mixed"&&n!==this.type)return;d=""+d;const c=this._nodes.get(d);if(typeof c>"u")throw new p(`Graph.${r}: could not find the "${d}" node in the graph.`);return We(!0,n==="mixed"?this.type:n,s,c,l)};const u="some"+o;i.prototype[u]=function(d,l){return!!this[r](d,l)};const a="every"+o;i.prototype[a]=function(d,l){return!this[r](d,(h,y)=>!l(h,y))}}function zn(i,t){const{name:e,type:n,direction:s}=t,o=e.slice(0,-1)+"Entries";i.prototype[o]=function(r){if(n!=="mixed"&&this.type!=="mixed"&&n!==this.type)return P.empty();r=""+r;const u=this._nodes.get(r);if(typeof u>"u")throw new p(`Graph.${o}: could not find the "${r}" node in the graph.`);return Cn(n==="mixed"?this.type:n,s,u)}}function Pn(i){On.forEach(t=>{In(i,t),jn(i,t),Tn(i,t),zn(i,t)})}function Ne(i,t,e,n,s){const o=n._nodes.values(),r=n.type;let u,a,d,l,c,h,y;for(;u=o.next(),u.done!==!0;){let E=!1;if(a=u.value,r!=="undirected"){l=a.out;for(d in l){c=l[d];do{if(h=c.target,E=!0,y=s(a.key,h.key,a.attributes,h.attributes,c.key,c.attributes,c.undirected),i&&y)return c;c=c.next}while(c)}}if(r!=="directed"){l=a.undirected;for(d in l)if(!(t&&a.key>d)){c=l[d];do{if(h=c.target,h.key!==d&&(h=c.source),E=!0,y=s(a.key,h.key,a.attributes,h.attributes,c.key,c.attributes,c.undirected),i&&y)return c;c=c.next}while(c)}}if(e&&!E&&(y=s(a.key,null,a.attributes,null,null,null,null),i&&y))return null}}function Wn(i,t){const e={key:i};return ft(t.attributes)||(e.attributes=O({},t.attributes)),e}function Kn(i,t,e){const n={key:t,source:e.source.key,target:e.target.key};return ft(e.attributes)||(n.attributes=O({},e.attributes)),i==="mixed"&&e.undirected&&(n.undirected=!0),n}function Hn(i){if(!C(i))throw new g('Graph.import: invalid serialized node. A serialized node should be a plain object with at least a "key" property.');if(!("key"in i))throw new g("Graph.import: serialized node is missing its key.");if("attributes"in i&&(!C(i.attributes)||i.attributes===null))throw new g("Graph.import: invalid attributes. Attributes should be a plain object, null or omitted.")}function Yn(i){if(!C(i))throw new g('Graph.import: invalid serialized edge. A serialized edge should be a plain object with at least a "source" & "target" property.');if(!("source"in i))throw new g("Graph.import: serialized edge is missing its source.");if(!("target"in i))throw new g("Graph.import: serialized edge is missing its target.");if("attributes"in i&&(!C(i.attributes)||i.attributes===null))throw new g("Graph.import: invalid attributes. Attributes should be a plain object, null or omitted.");if("undirected"in i&&typeof i.undirected!="boolean")throw new g("Graph.import: invalid undirectedness information. Undirected should be boolean or omitted.")}const Vn=Jt(),Jn=new Set(["directed","undirected","mixed"]),qe=new Set(["domain","_events","_eventsCount","_maxListeners"]),qn=[{name:i=>`${i}Edge`,generateKey:!0},{name:i=>`${i}DirectedEdge`,generateKey:!0,type:"directed"},{name:i=>`${i}UndirectedEdge`,generateKey:!0,type:"undirected"},{name:i=>`${i}EdgeWithKey`},{name:i=>`${i}DirectedEdgeWithKey`,type:"directed"},{name:i=>`${i}UndirectedEdgeWithKey`,type:"undirected"}],Zn={allowSelfLoops:!0,multi:!1,type:"mixed"};function Qn(i,t,e){if(e&&!C(e))throw new g(`Graph.addNode: invalid attributes. Expecting an object but got "${e}"`);if(t=""+t,e=e||{},i._nodes.has(t))throw new w(`Graph.addNode: the "${t}" node already exist in the graph.`);const n=new i.NodeDataClass(t,e);return i._nodes.set(t,n),i.emit("nodeAdded",{key:t,attributes:e}),n}function Ze(i,t,e){const n=new i.NodeDataClass(t,e);return i._nodes.set(t,n),i.emit("nodeAdded",{key:t,attributes:e}),n}function Et(i,t,e,n,s,o,r,u){if(!n&&i.type==="undirected")throw new w(`Graph.${t}: you cannot add a directed edge to an undirected graph. Use the #.addEdge or #.addUndirectedEdge instead.`);if(n&&i.type==="directed")throw new w(`Graph.${t}: you cannot add an undirected edge to a directed graph. Use the #.addEdge or #.addDirectedEdge instead.`);if(u&&!C(u))throw new g(`Graph.${t}: invalid attributes. Expecting an object but got "${u}"`);if(o=""+o,r=""+r,u=u||{},!i.allowSelfLoops&&o===r)throw new w(`Graph.${t}: source & target are the same ("${o}"), thus creating a loop explicitly forbidden by this graph 'allowSelfLoops' option set to false.`);const a=i._nodes.get(o),d=i._nodes.get(r);if(!a)throw new p(`Graph.${t}: source node "${o}" not found.`);if(!d)throw new p(`Graph.${t}: target node "${r}" not found.`);const l={key:null,undirected:n,source:o,target:r,attributes:u};if(e)s=i._edgeKeyGenerator();else if(s=""+s,i._edges.has(s))throw new w(`Graph.${t}: the "${s}" edge already exists in the graph.`);if(!i.multi&&(n?typeof a.undirected[r]<"u":typeof a.out[r]<"u"))throw new w(`Graph.${t}: an edge linking "${o}" to "${r}" already exists. If you really want to add multiple edges linking those nodes, you should create a multi graph by using the 'multi' option.`);const c=new pe(n,s,a,d,u);i._edges.set(s,c);const h=o===r;return n?(a.undirectedDegree++,d.undirectedDegree++,h&&(a.undirectedLoops++,i._undirectedSelfLoopCount++)):(a.outDegree++,d.inDegree++,h&&(a.directedLoops++,i._directedSelfLoopCount++)),i.multi?c.attachMulti():c.attach(),n?i._undirectedSize++:i._directedSize++,l.key=s,i.emit("edgeAdded",l),s}function Xn(i,t,e,n,s,o,r,u,a){if(!n&&i.type==="undirected")throw new w(`Graph.${t}: you cannot merge/update a directed edge to an undirected graph. Use the #.mergeEdge/#.updateEdge or #.addUndirectedEdge instead.`);if(n&&i.type==="directed")throw new w(`Graph.${t}: you cannot merge/update an undirected edge to a directed graph. Use the #.mergeEdge/#.updateEdge or #.addDirectedEdge instead.`);if(u){if(a){if(typeof u!="function")throw new g(`Graph.${t}: invalid updater function. Expecting a function but got "${u}"`)}else if(!C(u))throw new g(`Graph.${t}: invalid attributes. Expecting an object but got "${u}"`)}o=""+o,r=""+r;let d;if(a&&(d=u,u=void 0),!i.allowSelfLoops&&o===r)throw new w(`Graph.${t}: source & target are the same ("${o}"), thus creating a loop explicitly forbidden by this graph 'allowSelfLoops' option set to false.`);let l=i._nodes.get(o),c=i._nodes.get(r),h,y;if(!e&&(h=i._edges.get(s),h)){if((h.source.key!==o||h.target.key!==r)&&(!n||h.source.key!==r||h.target.key!==o))throw new w(`Graph.${t}: inconsistency detected when attempting to merge the "${s}" edge with "${o}" source & "${r}" target vs. ("${h.source.key}", "${h.target.key}").`);y=h}if(!y&&!i.multi&&l&&(y=n?l.undirected[r]:l.out[r]),y){const j=[y.key,!1,!1,!1];if(a?!d:!u)return j;if(a){const k=y.attributes;y.attributes=d(k),i.emit("edgeAttributesUpdated",{type:"replace",key:y.key,attributes:y.attributes})}else O(y.attributes,u),i.emit("edgeAttributesUpdated",{type:"merge",key:y.key,attributes:y.attributes,data:u});return j}u=u||{},a&&d&&(u=d(u));const E={key:null,undirected:n,source:o,target:r,attributes:u};if(e)s=i._edgeKeyGenerator();else if(s=""+s,i._edges.has(s))throw new w(`Graph.${t}: the "${s}" edge already exists in the graph.`);let L=!1,S=!1;l||(l=Ze(i,o,{}),L=!0,o===r&&(c=l,S=!0)),c||(c=Ze(i,r,{}),S=!0),h=new pe(n,s,l,c,u),i._edges.set(s,h);const F=o===r;return n?(l.undirectedDegree++,c.undirectedDegree++,F&&(l.undirectedLoops++,i._undirectedSelfLoopCount++)):(l.outDegree++,c.inDegree++,F&&(l.directedLoops++,i._directedSelfLoopCount++)),i.multi?h.attachMulti():h.attach(),n?i._undirectedSize++:i._directedSize++,E.key=s,i.emit("edgeAdded",E),[s,!0,L,S]}function fe(i,t){i._edges.delete(t.key);const{source:e,target:n,attributes:s}=t,o=t.undirected,r=e===n;o?(e.undirectedDegree--,n.undirectedDegree--,r&&(e.undirectedLoops--,i._undirectedSelfLoopCount--)):(e.outDegree--,n.inDegree--,r&&(e.directedLoops--,i._directedSelfLoopCount--)),i.multi?t.detachMulti():t.detach(),o?i._undirectedSize--:i._directedSize--,i.emit("edgeDropped",{key:t.key,attributes:s,source:e.key,target:n.key,undirected:o})}class N extends Ie.exports.EventEmitter{constructor(t){if(super(),t=O({},Zn,t),typeof t.multi!="boolean")throw new g(`Graph.constructor: invalid 'multi' option. Expecting a boolean but got "${t.multi}".`);if(!Jn.has(t.type))throw new g(`Graph.constructor: invalid 'type' option. Should be one of "mixed", "directed" or "undirected" but got "${t.type}".`);if(typeof t.allowSelfLoops!="boolean")throw new g(`Graph.constructor: invalid 'allowSelfLoops' option. Expecting a boolean but got "${t.allowSelfLoops}".`);const e=t.type==="mixed"?lt:t.type==="directed"?pt:gt;K(this,"NodeDataClass",e);const n="geid_"+Vn()+"_";let s=0;const o=()=>{let r;do r=n+s++;while(this._edges.has(r));return r};K(this,"_attributes",{}),K(this,"_nodes",new Map),K(this,"_edges",new Map),K(this,"_directedSize",0),K(this,"_undirectedSize",0),K(this,"_directedSelfLoopCount",0),K(this,"_undirectedSelfLoopCount",0),K(this,"_edgeKeyGenerator",o),K(this,"_options",t),qe.forEach(r=>K(this,r,this[r])),V(this,"order",()=>this._nodes.size),V(this,"size",()=>this._edges.size),V(this,"directedSize",()=>this._directedSize),V(this,"undirectedSize",()=>this._undirectedSize),V(this,"selfLoopCount",()=>this._directedSelfLoopCount+this._undirectedSelfLoopCount),V(this,"directedSelfLoopCount",()=>this._directedSelfLoopCount),V(this,"undirectedSelfLoopCount",()=>this._undirectedSelfLoopCount),V(this,"multi",this._options.multi),V(this,"type",this._options.type),V(this,"allowSelfLoops",this._options.allowSelfLoops),V(this,"implementation",()=>"graphology")}_resetInstanceCounters(){this._directedSize=0,this._undirectedSize=0,this._directedSelfLoopCount=0,this._undirectedSelfLoopCount=0}hasNode(t){return this._nodes.has(""+t)}hasDirectedEdge(t,e){if(this.type==="undirected")return!1;if(arguments.length===1){const n=""+t,s=this._edges.get(n);return!!s&&!s.undirected}else if(arguments.length===2){t=""+t,e=""+e;const n=this._nodes.get(t);return n?n.out.hasOwnProperty(e):!1}throw new g(`Graph.hasDirectedEdge: invalid arity (${arguments.length}, instead of 1 or 2). You can either ask for an edge id or for the existence of an edge between a source & a target.`)}hasUndirectedEdge(t,e){if(this.type==="directed")return!1;if(arguments.length===1){const n=""+t,s=this._edges.get(n);return!!s&&s.undirected}else if(arguments.length===2){t=""+t,e=""+e;const n=this._nodes.get(t);return n?n.undirected.hasOwnProperty(e):!1}throw new g(`Graph.hasDirectedEdge: invalid arity (${arguments.length}, instead of 1 or 2). You can either ask for an edge id or for the existence of an edge between a source & a target.`)}hasEdge(t,e){if(arguments.length===1){const n=""+t;return this._edges.has(n)}else if(arguments.length===2){t=""+t,e=""+e;const n=this._nodes.get(t);return n?typeof n.out<"u"&&n.out.hasOwnProperty(e)||typeof n.undirected<"u"&&n.undirected.hasOwnProperty(e):!1}throw new g(`Graph.hasEdge: invalid arity (${arguments.length}, instead of 1 or 2). You can either ask for an edge id or for the existence of an edge between a source & a target.`)}directedEdge(t,e){if(this.type==="undirected")return;if(t=""+t,e=""+e,this.multi)throw new w("Graph.directedEdge: this method is irrelevant with multigraphs since there might be multiple edges between source & target. See #.directedEdges instead.");const n=this._nodes.get(t);if(!n)throw new p(`Graph.directedEdge: could not find the "${t}" source node in the graph.`);if(!this._nodes.has(e))throw new p(`Graph.directedEdge: could not find the "${e}" target node in the graph.`);const s=n.out&&n.out[e]||void 0;if(s)return s.key}undirectedEdge(t,e){if(this.type==="directed")return;if(t=""+t,e=""+e,this.multi)throw new w("Graph.undirectedEdge: this method is irrelevant with multigraphs since there might be multiple edges between source & target. See #.undirectedEdges instead.");const n=this._nodes.get(t);if(!n)throw new p(`Graph.undirectedEdge: could not find the "${t}" source node in the graph.`);if(!this._nodes.has(e))throw new p(`Graph.undirectedEdge: could not find the "${e}" target node in the graph.`);const s=n.undirected&&n.undirected[e]||void 0;if(s)return s.key}edge(t,e){if(this.multi)throw new w("Graph.edge: this method is irrelevant with multigraphs since there might be multiple edges between source & target. See #.edges instead.");t=""+t,e=""+e;const n=this._nodes.get(t);if(!n)throw new p(`Graph.edge: could not find the "${t}" source node in the graph.`);if(!this._nodes.has(e))throw new p(`Graph.edge: could not find the "${e}" target node in the graph.`);const s=n.out&&n.out[e]||n.undirected&&n.undirected[e]||void 0;if(s)return s.key}areDirectedNeighbors(t,e){t=""+t,e=""+e;const n=this._nodes.get(t);if(!n)throw new p(`Graph.areDirectedNeighbors: could not find the "${t}" node in the graph.`);return this.type==="undirected"?!1:e in n.in||e in n.out}areOutNeighbors(t,e){t=""+t,e=""+e;const n=this._nodes.get(t);if(!n)throw new p(`Graph.areOutNeighbors: could not find the "${t}" node in the graph.`);return this.type==="undirected"?!1:e in n.out}areInNeighbors(t,e){t=""+t,e=""+e;const n=this._nodes.get(t);if(!n)throw new p(`Graph.areInNeighbors: could not find the "${t}" node in the graph.`);return this.type==="undirected"?!1:e in n.in}areUndirectedNeighbors(t,e){t=""+t,e=""+e;const n=this._nodes.get(t);if(!n)throw new p(`Graph.areUndirectedNeighbors: could not find the "${t}" node in the graph.`);return this.type==="directed"?!1:e in n.undirected}areNeighbors(t,e){t=""+t,e=""+e;const n=this._nodes.get(t);if(!n)throw new p(`Graph.areNeighbors: could not find the "${t}" node in the graph.`);return this.type!=="undirected"&&(e in n.in||e in n.out)||this.type!=="directed"&&e in n.undirected}areInboundNeighbors(t,e){t=""+t,e=""+e;const n=this._nodes.get(t);if(!n)throw new p(`Graph.areInboundNeighbors: could not find the "${t}" node in the graph.`);return this.type!=="undirected"&&e in n.in||this.type!=="directed"&&e in n.undirected}areOutboundNeighbors(t,e){t=""+t,e=""+e;const n=this._nodes.get(t);if(!n)throw new p(`Graph.areOutboundNeighbors: could not find the "${t}" node in the graph.`);return this.type!=="undirected"&&e in n.out||this.type!=="directed"&&e in n.undirected}inDegree(t){t=""+t;const e=this._nodes.get(t);if(!e)throw new p(`Graph.inDegree: could not find the "${t}" node in the graph.`);return this.type==="undirected"?0:e.inDegree}outDegree(t){t=""+t;const e=this._nodes.get(t);if(!e)throw new p(`Graph.outDegree: could not find the "${t}" node in the graph.`);return this.type==="undirected"?0:e.outDegree}directedDegree(t){t=""+t;const e=this._nodes.get(t);if(!e)throw new p(`Graph.directedDegree: could not find the "${t}" node in the graph.`);return this.type==="undirected"?0:e.inDegree+e.outDegree}undirectedDegree(t){t=""+t;const e=this._nodes.get(t);if(!e)throw new p(`Graph.undirectedDegree: could not find the "${t}" node in the graph.`);return this.type==="directed"?0:e.undirectedDegree}inboundDegree(t){t=""+t;const e=this._nodes.get(t);if(!e)throw new p(`Graph.inboundDegree: could not find the "${t}" node in the graph.`);let n=0;return this.type!=="directed"&&(n+=e.undirectedDegree),this.type!=="undirected"&&(n+=e.inDegree),n}outboundDegree(t){t=""+t;const e=this._nodes.get(t);if(!e)throw new p(`Graph.outboundDegree: could not find the "${t}" node in the graph.`);let n=0;return this.type!=="directed"&&(n+=e.undirectedDegree),this.type!=="undirected"&&(n+=e.outDegree),n}degree(t){t=""+t;const e=this._nodes.get(t);if(!e)throw new p(`Graph.degree: could not find the "${t}" node in the graph.`);let n=0;return this.type!=="directed"&&(n+=e.undirectedDegree),this.type!=="undirected"&&(n+=e.inDegree+e.outDegree),n}inDegreeWithoutSelfLoops(t){t=""+t;const e=this._nodes.get(t);if(!e)throw new p(`Graph.inDegreeWithoutSelfLoops: could not find the "${t}" node in the graph.`);return this.type==="undirected"?0:e.inDegree-e.directedLoops}outDegreeWithoutSelfLoops(t){t=""+t;const e=this._nodes.get(t);if(!e)throw new p(`Graph.outDegreeWithoutSelfLoops: could not find the "${t}" node in the graph.`);return this.type==="undirected"?0:e.outDegree-e.directedLoops}directedDegreeWithoutSelfLoops(t){t=""+t;const e=this._nodes.get(t);if(!e)throw new p(`Graph.directedDegreeWithoutSelfLoops: could not find the "${t}" node in the graph.`);return this.type==="undirected"?0:e.inDegree+e.outDegree-e.directedLoops*2}undirectedDegreeWithoutSelfLoops(t){t=""+t;const e=this._nodes.get(t);if(!e)throw new p(`Graph.undirectedDegreeWithoutSelfLoops: could not find the "${t}" node in the graph.`);return this.type==="directed"?0:e.undirectedDegree-e.undirectedLoops*2}inboundDegreeWithoutSelfLoops(t){t=""+t;const e=this._nodes.get(t);if(!e)throw new p(`Graph.inboundDegreeWithoutSelfLoops: could not find the "${t}" node in the graph.`);let n=0,s=0;return this.type!=="directed"&&(n+=e.undirectedDegree,s+=e.undirectedLoops*2),this.type!=="undirected"&&(n+=e.inDegree,s+=e.directedLoops),n-s}outboundDegreeWithoutSelfLoops(t){t=""+t;const e=this._nodes.get(t);if(!e)throw new p(`Graph.outboundDegreeWithoutSelfLoops: could not find the "${t}" node in the graph.`);let n=0,s=0;return this.type!=="directed"&&(n+=e.undirectedDegree,s+=e.undirectedLoops*2),this.type!=="undirected"&&(n+=e.outDegree,s+=e.directedLoops),n-s}degreeWithoutSelfLoops(t){t=""+t;const e=this._nodes.get(t);if(!e)throw new p(`Graph.degreeWithoutSelfLoops: could not find the "${t}" node in the graph.`);let n=0,s=0;return this.type!=="directed"&&(n+=e.undirectedDegree,s+=e.undirectedLoops*2),this.type!=="undirected"&&(n+=e.inDegree+e.outDegree,s+=e.directedLoops*2),n-s}source(t){t=""+t;const e=this._edges.get(t);if(!e)throw new p(`Graph.source: could not find the "${t}" edge in the graph.`);return e.source.key}target(t){t=""+t;const e=this._edges.get(t);if(!e)throw new p(`Graph.target: could not find the "${t}" edge in the graph.`);return e.target.key}extremities(t){t=""+t;const e=this._edges.get(t);if(!e)throw new p(`Graph.extremities: could not find the "${t}" edge in the graph.`);return[e.source.key,e.target.key]}opposite(t,e){t=""+t,e=""+e;const n=this._edges.get(e);if(!n)throw new p(`Graph.opposite: could not find the "${e}" edge in the graph.`);const s=n.source.key,o=n.target.key;if(t===s)return o;if(t===o)return s;throw new p(`Graph.opposite: the "${t}" node is not attached to the "${e}" edge (${s}, ${o}).`)}hasExtremity(t,e){t=""+t,e=""+e;const n=this._edges.get(t);if(!n)throw new p(`Graph.hasExtremity: could not find the "${t}" edge in the graph.`);return n.source.key===e||n.target.key===e}isUndirected(t){t=""+t;const e=this._edges.get(t);if(!e)throw new p(`Graph.isUndirected: could not find the "${t}" edge in the graph.`);return e.undirected}isDirected(t){t=""+t;const e=this._edges.get(t);if(!e)throw new p(`Graph.isDirected: could not find the "${t}" edge in the graph.`);return!e.undirected}isSelfLoop(t){t=""+t;const e=this._edges.get(t);if(!e)throw new p(`Graph.isSelfLoop: could not find the "${t}" edge in the graph.`);return e.source===e.target}addNode(t,e){return Qn(this,t,e).key}mergeNode(t,e){if(e&&!C(e))throw new g(`Graph.mergeNode: invalid attributes. Expecting an object but got "${e}"`);t=""+t,e=e||{};let n=this._nodes.get(t);return n?(e&&(O(n.attributes,e),this.emit("nodeAttributesUpdated",{type:"merge",key:t,attributes:n.attributes,data:e})),[t,!1]):(n=new this.NodeDataClass(t,e),this._nodes.set(t,n),this.emit("nodeAdded",{key:t,attributes:e}),[t,!0])}updateNode(t,e){if(e&&typeof e!="function")throw new g(`Graph.updateNode: invalid updater function. Expecting a function but got "${e}"`);t=""+t;let n=this._nodes.get(t);if(n){if(e){const o=n.attributes;n.attributes=e(o),this.emit("nodeAttributesUpdated",{type:"replace",key:t,attributes:n.attributes})}return[t,!1]}const s=e?e({}):{};return n=new this.NodeDataClass(t,s),this._nodes.set(t,n),this.emit("nodeAdded",{key:t,attributes:s}),[t,!0]}dropNode(t){t=""+t;const e=this._nodes.get(t);if(!e)throw new p(`Graph.dropNode: could not find the "${t}" node in the graph.`);let n;if(this.type!=="undirected"){for(const s in e.out){n=e.out[s];do fe(this,n),n=n.next;while(n)}for(const s in e.in){n=e.in[s];do fe(this,n),n=n.next;while(n)}}if(this.type!=="directed")for(const s in e.undirected){n=e.undirected[s];do fe(this,n),n=n.next;while(n)}this._nodes.delete(t),this.emit("nodeDropped",{key:t,attributes:e.attributes})}dropEdge(t){let e;if(arguments.length>1){const n=""+arguments[0],s=""+arguments[1];if(e=Y(this,n,s,this.type),!e)throw new p(`Graph.dropEdge: could not find the "${n}" -> "${s}" edge in the graph.`)}else if(t=""+t,e=this._edges.get(t),!e)throw new p(`Graph.dropEdge: could not find the "${t}" edge in the graph.`);return fe(this,e),this}dropDirectedEdge(t,e){if(arguments.length<2)throw new w("Graph.dropDirectedEdge: it does not make sense to try and drop a directed edge by key. What if the edge with this key is undirected? Use #.dropEdge for this purpose instead.");if(this.multi)throw new w("Graph.dropDirectedEdge: cannot use a {source,target} combo when dropping an edge in a MultiGraph since we cannot infer the one you want to delete as there could be multiple ones.");t=""+t,e=""+e;const n=Y(this,t,e,"directed");if(!n)throw new p(`Graph.dropDirectedEdge: could not find a "${t}" -> "${e}" edge in the graph.`);return fe(this,n),this}dropUndirectedEdge(t,e){if(arguments.length<2)throw new w("Graph.dropUndirectedEdge: it does not make sense to drop a directed edge by key. What if the edge with this key is undirected? Use #.dropEdge for this purpose instead.");if(this.multi)throw new w("Graph.dropUndirectedEdge: cannot use a {source,target} combo when dropping an edge in a MultiGraph since we cannot infer the one you want to delete as there could be multiple ones.");const n=Y(this,t,e,"undirected");if(!n)throw new p(`Graph.dropUndirectedEdge: could not find a "${t}" -> "${e}" edge in the graph.`);return fe(this,n),this}clear(){this._edges.clear(),this._nodes.clear(),this._resetInstanceCounters(),this.emit("cleared")}clearEdges(){const t=this._nodes.values();let e;for(;e=t.next(),e.done!==!0;)e.value.clear();this._edges.clear(),this._resetInstanceCounters(),this.emit("edgesCleared")}getAttribute(t){return this._attributes[t]}getAttributes(){return this._attributes}hasAttribute(t){return this._attributes.hasOwnProperty(t)}setAttribute(t,e){return this._attributes[t]=e,this.emit("attributesUpdated",{type:"set",attributes:this._attributes,name:t}),this}updateAttribute(t,e){if(typeof e!="function")throw new g("Graph.updateAttribute: updater should be a function.");const n=this._attributes[t];return this._attributes[t]=e(n),this.emit("attributesUpdated",{type:"set",attributes:this._attributes,name:t}),this}removeAttribute(t){return delete this._attributes[t],this.emit("attributesUpdated",{type:"remove",attributes:this._attributes,name:t}),this}replaceAttributes(t){if(!C(t))throw new g("Graph.replaceAttributes: provided attributes are not a plain object.");return this._attributes=t,this.emit("attributesUpdated",{type:"replace",attributes:this._attributes}),this}mergeAttributes(t){if(!C(t))throw new g("Graph.mergeAttributes: provided attributes are not a plain object.");return O(this._attributes,t),this.emit("attributesUpdated",{type:"merge",attributes:this._attributes,data:t}),this}updateAttributes(t){if(typeof t!="function")throw new g("Graph.updateAttributes: provided updater is not a function.");return this._attributes=t(this._attributes),this.emit("attributesUpdated",{type:"update",attributes:this._attributes}),this}updateEachNodeAttributes(t,e){if(typeof t!="function")throw new g("Graph.updateEachNodeAttributes: expecting an updater function.");if(e&&!Je(e))throw new g("Graph.updateEachNodeAttributes: invalid hints. Expecting an object having the following shape: {attributes?: [string]}");const n=this._nodes.values();let s,o;for(;s=n.next(),s.done!==!0;)o=s.value,o.attributes=t(o.key,o.attributes);this.emit("eachNodeAttributesUpdated",{hints:e||null})}updateEachEdgeAttributes(t,e){if(typeof t!="function")throw new g("Graph.updateEachEdgeAttributes: expecting an updater function.");if(e&&!Je(e))throw new g("Graph.updateEachEdgeAttributes: invalid hints. Expecting an object having the following shape: {attributes?: [string]}");const n=this._edges.values();let s,o,r,u;for(;s=n.next(),s.done!==!0;)o=s.value,r=o.source,u=o.target,o.attributes=t(o.key,o.attributes,r.key,u.key,r.attributes,u.attributes,o.undirected);this.emit("eachEdgeAttributesUpdated",{hints:e||null})}forEachAdjacencyEntry(t){if(typeof t!="function")throw new g("Graph.forEachAdjacencyEntry: expecting a callback.");Ne(!1,!1,!1,this,t)}forEachAdjacencyEntryWithOrphans(t){if(typeof t!="function")throw new g("Graph.forEachAdjacencyEntryWithOrphans: expecting a callback.");Ne(!1,!1,!0,this,t)}forEachAssymetricAdjacencyEntry(t){if(typeof t!="function")throw new g("Graph.forEachAssymetricAdjacencyEntry: expecting a callback.");Ne(!1,!0,!1,this,t)}forEachAssymetricAdjacencyEntryWithOrphans(t){if(typeof t!="function")throw new g("Graph.forEachAssymetricAdjacencyEntryWithOrphans: expecting a callback.");Ne(!1,!0,!0,this,t)}nodes(){return typeof Array.from=="function"?Array.from(this._nodes.keys()):ct(this._nodes.keys(),this._nodes.size)}forEachNode(t){if(typeof t!="function")throw new g("Graph.forEachNode: expecting a callback.");const e=this._nodes.values();let n,s;for(;n=e.next(),n.done!==!0;)s=n.value,t(s.key,s.attributes)}findNode(t){if(typeof t!="function")throw new g("Graph.findNode: expecting a callback.");const e=this._nodes.values();let n,s;for(;n=e.next(),n.done!==!0;)if(s=n.value,t(s.key,s.attributes))return s.key}mapNodes(t){if(typeof t!="function")throw new g("Graph.mapNode: expecting a callback.");const e=this._nodes.values();let n,s;const o=new Array(this.order);let r=0;for(;n=e.next(),n.done!==!0;)s=n.value,o[r++]=t(s.key,s.attributes);return o}someNode(t){if(typeof t!="function")throw new g("Graph.someNode: expecting a callback.");const e=this._nodes.values();let n,s;for(;n=e.next(),n.done!==!0;)if(s=n.value,t(s.key,s.attributes))return!0;return!1}everyNode(t){if(typeof t!="function")throw new g("Graph.everyNode: expecting a callback.");const e=this._nodes.values();let n,s;for(;n=e.next(),n.done!==!0;)if(s=n.value,!t(s.key,s.attributes))return!1;return!0}filterNodes(t){if(typeof t!="function")throw new g("Graph.filterNodes: expecting a callback.");const e=this._nodes.values();let n,s;const o=[];for(;n=e.next(),n.done!==!0;)s=n.value,t(s.key,s.attributes)&&o.push(s.key);return o}reduceNodes(t,e){if(typeof t!="function")throw new g("Graph.reduceNodes: expecting a callback.");if(arguments.length<2)throw new g("Graph.reduceNodes: missing initial value. You must provide it because the callback takes more than one argument and we cannot infer the initial value from the first iteration, as you could with a simple array.");let n=e;const s=this._nodes.values();let o,r;for(;o=s.next(),o.done!==!0;)r=o.value,n=t(n,r.key,r.attributes);return n}nodeEntries(){const t=this._nodes.values();return new P(()=>{const e=t.next();if(e.done)return e;const n=e.value;return{value:{node:n.key,attributes:n.attributes},done:!1}})}export(){const t=new Array(this._nodes.size);let e=0;this._nodes.forEach((s,o)=>{t[e++]=Wn(o,s)});const n=new Array(this._edges.size);return e=0,this._edges.forEach((s,o)=>{n[e++]=Kn(this.type,o,s)}),{options:{type:this.type,multi:this.multi,allowSelfLoops:this.allowSelfLoops},attributes:this.getAttributes(),nodes:t,edges:n}}import(t,e=!1){if(t instanceof N)return t.forEachNode((a,d)=>{e?this.mergeNode(a,d):this.addNode(a,d)}),t.forEachEdge((a,d,l,c,h,y,E)=>{e?E?this.mergeUndirectedEdgeWithKey(a,l,c,d):this.mergeDirectedEdgeWithKey(a,l,c,d):E?this.addUndirectedEdgeWithKey(a,l,c,d):this.addDirectedEdgeWithKey(a,l,c,d)}),this;if(!C(t))throw new g("Graph.import: invalid argument. Expecting a serialized graph or, alternatively, a Graph instance.");if(t.attributes){if(!C(t.attributes))throw new g("Graph.import: invalid attributes. Expecting a plain object.");e?this.mergeAttributes(t.attributes):this.replaceAttributes(t.attributes)}let n,s,o,r,u;if(t.nodes){if(o=t.nodes,!Array.isArray(o))throw new g("Graph.import: invalid nodes. Expecting an array.");for(n=0,s=o.length;n<s;n++){r=o[n],Hn(r);const{key:a,attributes:d}=r;e?this.mergeNode(a,d):this.addNode(a,d)}}if(t.edges){let a=!1;if(this.type==="undirected"&&(a=!0),o=t.edges,!Array.isArray(o))throw new g("Graph.import: invalid edges. Expecting an array.");for(n=0,s=o.length;n<s;n++){u=o[n],Yn(u);const{source:d,target:l,attributes:c,undirected:h=a}=u;let y;"key"in u?(y=e?h?this.mergeUndirectedEdgeWithKey:this.mergeDirectedEdgeWithKey:h?this.addUndirectedEdgeWithKey:this.addDirectedEdgeWithKey,y.call(this,u.key,d,l,c)):(y=e?h?this.mergeUndirectedEdge:this.mergeDirectedEdge:h?this.addUndirectedEdge:this.addDirectedEdge,y.call(this,d,l,c))}}return this}nullCopy(t){const e=new N(O({},this._options,t));return e.replaceAttributes(O({},this.getAttributes())),e}emptyCopy(t){const e=this.nullCopy(t);return this._nodes.forEach((n,s)=>{const o=O({},n.attributes);n=new e.NodeDataClass(s,o),e._nodes.set(s,n)}),e}copy(t){if(t=t||{},typeof t.type=="string"&&t.type!==this.type&&t.type!=="mixed")throw new w(`Graph.copy: cannot create an incompatible copy from "${this.type}" type to "${t.type}" because this would mean losing information about the current graph.`);if(typeof t.multi=="boolean"&&t.multi!==this.multi&&t.multi!==!0)throw new w("Graph.copy: cannot create an incompatible copy by downgrading a multi graph to a simple one because this would mean losing information about the current graph.");if(typeof t.allowSelfLoops=="boolean"&&t.allowSelfLoops!==this.allowSelfLoops&&t.allowSelfLoops!==!0)throw new w("Graph.copy: cannot create an incompatible copy from a graph allowing self loops to one that does not because this would mean losing information about the current graph.");const e=this.emptyCopy(t),n=this._edges.values();let s,o;for(;s=n.next(),s.done!==!0;)o=s.value,Et(e,"copy",!1,o.undirected,o.key,o.source.key,o.target.key,O({},o.attributes));return e}toJSON(){return this.export()}toString(){return"[object Graph]"}inspect(){const t={};this._nodes.forEach((o,r)=>{t[r]=o.attributes});const e={},n={};this._edges.forEach((o,r)=>{const u=o.undirected?"--":"->";let a="",d=o.source.key,l=o.target.key,c;o.undirected&&d>l&&(c=d,d=l,l=c);const h=`(${d})${u}(${l})`;r.startsWith("geid_")?this.multi&&(typeof n[h]>"u"?n[h]=0:n[h]++,a+=`${n[h]}. `):a+=`[${r}]: `,a+=h,e[a]=o.attributes});const s={};for(const o in this)this.hasOwnProperty(o)&&!qe.has(o)&&typeof this[o]!="function"&&typeof o!="symbol"&&(s[o]=this[o]);return s.attributes=this._attributes,s.nodes=t,s.edges=e,K(s,"constructor",this.constructor),s}}typeof Symbol<"u"&&(N.prototype[Symbol.for("nodejs.util.inspect.custom")]=N.prototype.inspect);qn.forEach(i=>{["add","merge","update"].forEach(t=>{const e=i.name(t),n=t==="add"?Et:Xn;i.generateKey?N.prototype[e]=function(s,o,r){return n(this,e,!0,(i.type||this.type)==="undirected",null,s,o,r,t==="update")}:N.prototype[e]=function(s,o,r,u){return n(this,e,!1,(i.type||this.type)==="undirected",s,o,r,u,t==="update")}})});un(N);mn(N);Un(N);Pn(N);class vt extends N{constructor(t){const e=O({type:"directed"},t);if("multi"in e&&e.multi!==!1)throw new g("DirectedGraph.from: inconsistent indication that the graph should be multi in given options!");if(e.type!=="directed")throw new g('DirectedGraph.from: inconsistent "'+e.type+'" type in given options!');super(e)}}class _t extends N{constructor(t){const e=O({type:"undirected"},t);if("multi"in e&&e.multi!==!1)throw new g("UndirectedGraph.from: inconsistent indication that the graph should be multi in given options!");if(e.type!=="undirected")throw new g('UndirectedGraph.from: inconsistent "'+e.type+'" type in given options!');super(e)}}class $t extends N{constructor(t){const e=O({multi:!0},t);if("multi"in e&&e.multi!==!0)throw new g("MultiGraph.from: inconsistent indication that the graph should be simple in given options!");super(e)}}class Gt extends N{constructor(t){const e=O({type:"directed",multi:!0},t);if("multi"in e&&e.multi!==!0)throw new g("MultiDirectedGraph.from: inconsistent indication that the graph should be simple in given options!");if(e.type!=="directed")throw new g('MultiDirectedGraph.from: inconsistent "'+e.type+'" type in given options!');super(e)}}class Dt extends N{constructor(t){const e=O({type:"undirected",multi:!0},t);if("multi"in e&&e.multi!==!0)throw new g("MultiUndirectedGraph.from: inconsistent indication that the graph should be simple in given options!");if(e.type!=="undirected")throw new g('MultiUndirectedGraph.from: inconsistent "'+e.type+'" type in given options!');super(e)}}function ge(i){i.from=function(t,e){const n=O({},t.options,e),s=new i(n);return s.import(t),s}}ge(N);ge(vt);ge(_t);ge($t);ge(Gt);ge(Dt);N.Graph=N;N.DirectedGraph=vt;N.UndirectedGraph=_t;N.MultiGraph=$t;N.MultiDirectedGraph=Gt;N.MultiUndirectedGraph=Dt;N.InvalidArgumentsGraphError=g;N.NotFoundGraphError=p;N.UsageGraphError=w;function Mn(i){return!i||typeof i!="object"||typeof i=="function"||Array.isArray(i)||i instanceof Set||i instanceof Map||i instanceof RegExp||i instanceof Date}function kt(i,t){i=i||{};var e={};for(var n in t){var s=i[n],o=t[n];if(!Mn(o)){e[n]=kt(s,o);continue}s===void 0?e[n]=o:e[n]=s}return e}var ei=kt,At=function(t){return t!==null&&typeof t=="object"&&typeof t.addUndirectedEdgeWithKey=="function"&&typeof t.dropNode=="function"&&typeof t.multi=="boolean"},ti=ei,ni=At,ii={dimensions:["x","y"],center:.5,scale:1};function Nt(i,t,e){if(!ni(t))throw new Error("graphology-layout/random: the given graph is not a valid graphology instance.");e=ti(e,ii);var n=e.dimensions;if(!Array.isArray(n)||n.length!==2)throw new Error("graphology-layout/random: given dimensions are invalid.");var s=e.center,o=e.scale,r=Math.PI*2,u=(s-.5)*o,a=t.order,d=n[0],l=n[1];function c(E,L){return L[d]=o*Math.cos(E*r/a)+u,L[l]=o*Math.sin(E*r/a)+u,L}var h=0;if(!i){var y={};return t.forEachNode(function(E){y[E]=c(h++,{})}),y}t.updateEachNodeAttributes(function(E,L){return c(h++,L),L},{attributes:n})}var Lt=Nt.bind(null,!1);Lt.assign=Nt.bind(null,!0);var ri=Lt,Fe={};function oi(i){return typeof i!="number"||isNaN(i)?1:i}function si(i,t){var e={},n=function(r){return typeof r>"u"?t:r};typeof t=="function"&&(n=t);var s=function(r){return n(r[i])},o=function(){return n(void 0)};return typeof i=="string"?(e.fromAttributes=s,e.fromGraph=function(r,u){return s(r.getNodeAttributes(u))},e.fromEntry=function(r,u){return s(u)}):typeof i=="function"?(e.fromAttributes=function(){throw new Error("graphology-utils/getters/createNodeValueGetter: irrelevant usage.")},e.fromGraph=function(r,u){return n(i(u,r.getNodeAttributes(u)))},e.fromEntry=function(r,u){return n(i(r,u))}):(e.fromAttributes=o,e.fromGraph=o,e.fromEntry=o),e}function St(i,t){var e={},n=function(r){return typeof r>"u"?t:r};typeof t=="function"&&(n=t);var s=function(r){return n(r[i])},o=function(){return n(void 0)};return typeof i=="string"?(e.fromAttributes=s,e.fromGraph=function(r,u){return s(r.getEdgeAttributes(u))},e.fromEntry=function(r,u){return s(u)},e.fromPartialEntry=e.fromEntry,e.fromMinimalEntry=e.fromEntry):typeof i=="function"?(e.fromAttributes=function(){throw new Error("graphology-utils/getters/createEdgeValueGetter: irrelevant usage.")},e.fromGraph=function(r,u){var a=r.extremities(u);return n(i(u,r.getEdgeAttributes(u),a[0],a[1],r.getNodeAttributes(a[0]),r.getNodeAttributes(a[1]),r.isUndirected(u)))},e.fromEntry=function(r,u,a,d,l,c,h){return n(i(r,u,a,d,l,c,h))},e.fromPartialEntry=function(r,u,a,d){return n(i(r,u,a,d))},e.fromMinimalEntry=function(r,u){return n(i(r,u))}):(e.fromAttributes=o,e.fromGraph=o,e.fromEntry=o,e.fromMinimalEntry=o),e}Fe.createNodeValueGetter=si;Fe.createEdgeValueGetter=St;Fe.createEdgeWeightGetter=function(i){return St(i,oi)};var U=0,B=1,_=2,$=3,M=4,ee=5,D=6,Qe=7,Le=8,Xe=9,ui=0,ai=1,di=2,R=0,H=1,T=2,ae=3,ie=4,x=5,z=6,q=7,Z=8,Me=3,J=10,hi=3,I=9,Ce=10,ci=function(t,e,n){var s,o,r,u,a,d,l,c,h,y,E=e.length,L=n.length,S=t.adjustSizes,F=t.barnesHutTheta*t.barnesHutTheta,j,k,v,G,X,b,m,f=[];for(r=0;r<E;r+=J)e[r+M]=e[r+_],e[r+ee]=e[r+$],e[r+_]=0,e[r+$]=0;if(t.outboundAttractionDistribution){for(j=0,r=0;r<E;r+=J)j+=e[r+D];j/=E/J}if(t.barnesHutOptimize){var oe=1/0,de=-1/0,se=1/0,he=-1/0,W,ce,Ue;for(r=0;r<E;r+=J)oe=Math.min(oe,e[r+U]),de=Math.max(de,e[r+U]),se=Math.min(se,e[r+B]),he=Math.max(he,e[r+B]);var ve=de-oe,_e=he-se;for(ve>_e?(se-=(ve-_e)/2,he=se+ve):(oe-=(_e-ve)/2,de=oe+_e),f[0+R]=-1,f[0+H]=(oe+de)/2,f[0+T]=(se+he)/2,f[0+ae]=Math.max(de-oe,he-se),f[0+ie]=-1,f[0+x]=-1,f[0+z]=0,f[0+q]=0,f[0+Z]=0,s=1,r=0;r<E;r+=J)for(o=0,Ue=Me;;)if(f[o+x]>=0){e[r+U]<f[o+H]?e[r+B]<f[o+T]?W=f[o+x]:W=f[o+x]+I:e[r+B]<f[o+T]?W=f[o+x]+I*2:W=f[o+x]+I*3,f[o+q]=(f[o+q]*f[o+z]+e[r+U]*e[r+D])/(f[o+z]+e[r+D]),f[o+Z]=(f[o+Z]*f[o+z]+e[r+B]*e[r+D])/(f[o+z]+e[r+D]),f[o+z]+=e[r+D],o=W;continue}else if(f[o+R]<0){f[o+R]=r;break}else{if(f[o+x]=s*I,c=f[o+ae]/2,h=f[o+x],f[h+R]=-1,f[h+H]=f[o+H]-c,f[h+T]=f[o+T]-c,f[h+ae]=c,f[h+ie]=h+I,f[h+x]=-1,f[h+z]=0,f[h+q]=0,f[h+Z]=0,h+=I,f[h+R]=-1,f[h+H]=f[o+H]-c,f[h+T]=f[o+T]+c,f[h+ae]=c,f[h+ie]=h+I,f[h+x]=-1,f[h+z]=0,f[h+q]=0,f[h+Z]=0,h+=I,f[h+R]=-1,f[h+H]=f[o+H]+c,f[h+T]=f[o+T]-c,f[h+ae]=c,f[h+ie]=h+I,f[h+x]=-1,f[h+z]=0,f[h+q]=0,f[h+Z]=0,h+=I,f[h+R]=-1,f[h+H]=f[o+H]+c,f[h+T]=f[o+T]+c,f[h+ae]=c,f[h+ie]=f[o+ie],f[h+x]=-1,f[h+z]=0,f[h+q]=0,f[h+Z]=0,s+=4,e[f[o+R]+U]<f[o+H]?e[f[o+R]+B]<f[o+T]?W=f[o+x]:W=f[o+x]+I:e[f[o+R]+B]<f[o+T]?W=f[o+x]+I*2:W=f[o+x]+I*3,f[o+z]=e[f[o+R]+D],f[o+q]=e[f[o+R]+U],f[o+Z]=e[f[o+R]+B],f[W+R]=f[o+R],f[o+R]=-1,e[r+U]<f[o+H]?e[r+B]<f[o+T]?ce=f[o+x]:ce=f[o+x]+I:e[r+B]<f[o+T]?ce=f[o+x]+I*2:ce=f[o+x]+I*3,W===ce)if(Ue--){o=W;continue}else{Ue=Me;break}f[ce+R]=r;break}}if(t.barnesHutOptimize)for(k=t.scalingRatio,r=0;r<E;r+=J)for(o=0;;)if(f[o+x]>=0)if(b=Math.pow(e[r+U]-f[o+q],2)+Math.pow(e[r+B]-f[o+Z],2),y=f[o+ae],4*y*y/b<F){if(v=e[r+U]-f[o+q],G=e[r+B]-f[o+Z],S===!0?b>0?(m=k*e[r+D]*f[o+z]/b,e[r+_]+=v*m,e[r+$]+=G*m):b<0&&(m=-k*e[r+D]*f[o+z]/Math.sqrt(b),e[r+_]+=v*m,e[r+$]+=G*m):b>0&&(m=k*e[r+D]*f[o+z]/b,e[r+_]+=v*m,e[r+$]+=G*m),o=f[o+ie],o<0)break;continue}else{o=f[o+x];continue}else{if(d=f[o+R],d>=0&&d!==r&&(v=e[r+U]-e[d+U],G=e[r+B]-e[d+B],b=v*v+G*G,S===!0?b>0?(m=k*e[r+D]*e[d+D]/b,e[r+_]+=v*m,e[r+$]+=G*m):b<0&&(m=-k*e[r+D]*e[d+D]/Math.sqrt(b),e[r+_]+=v*m,e[r+$]+=G*m):b>0&&(m=k*e[r+D]*e[d+D]/b,e[r+_]+=v*m,e[r+$]+=G*m)),o=f[o+ie],o<0)break;continue}else for(k=t.scalingRatio,u=0;u<E;u+=J)for(a=0;a<u;a+=J)v=e[u+U]-e[a+U],G=e[u+B]-e[a+B],S===!0?(b=Math.sqrt(v*v+G*G)-e[u+Le]-e[a+Le],b>0?(m=k*e[u+D]*e[a+D]/b/b,e[u+_]+=v*m,e[u+$]+=G*m,e[a+_]-=v*m,e[a+$]-=G*m):b<0&&(m=100*k*e[u+D]*e[a+D],e[u+_]+=v*m,e[u+$]+=G*m,e[a+_]-=v*m,e[a+$]-=G*m)):(b=Math.sqrt(v*v+G*G),b>0&&(m=k*e[u+D]*e[a+D]/b/b,e[u+_]+=v*m,e[u+$]+=G*m,e[a+_]-=v*m,e[a+$]-=G*m));for(h=t.gravity/t.scalingRatio,k=t.scalingRatio,r=0;r<E;r+=J)m=0,v=e[r+U],G=e[r+B],b=Math.sqrt(Math.pow(v,2)+Math.pow(G,2)),t.strongGravityMode?b>0&&(m=k*e[r+D]*h):b>0&&(m=k*e[r+D]*h/b),e[r+_]-=v*m,e[r+$]-=G*m;for(k=1*(t.outboundAttractionDistribution?j:1),l=0;l<L;l+=hi)u=n[l+ui],a=n[l+ai],c=n[l+di],X=Math.pow(c,t.edgeWeightInfluence),v=e[u+U]-e[a+U],G=e[u+B]-e[a+B],S===!0?(b=Math.sqrt(v*v+G*G)-e[u+Le]-e[a+Le],t.linLogMode?t.outboundAttractionDistribution?b>0&&(m=-k*X*Math.log(1+b)/b/e[u+D]):b>0&&(m=-k*X*Math.log(1+b)/b):t.outboundAttractionDistribution?b>0&&(m=-k*X/e[u+D]):b>0&&(m=-k*X)):(b=Math.sqrt(Math.pow(v,2)+Math.pow(G,2)),t.linLogMode?t.outboundAttractionDistribution?b>0&&(m=-k*X*Math.log(1+b)/b/e[u+D]):b>0&&(m=-k*X*Math.log(1+b)/b):t.outboundAttractionDistribution?(b=1,m=-k*X/e[u+D]):(b=1,m=-k*X)),b>0&&(e[u+_]+=v*m,e[u+$]+=G*m,e[a+_]-=v*m,e[a+$]-=G*m);var $e,ye,Ge,ue,De,ke;if(S===!0)for(r=0;r<E;r+=J)e[r+Xe]!==1&&($e=Math.sqrt(Math.pow(e[r+_],2)+Math.pow(e[r+$],2)),$e>Ce&&(e[r+_]=e[r+_]*Ce/$e,e[r+$]=e[r+$]*Ce/$e),ye=e[r+D]*Math.sqrt((e[r+M]-e[r+_])*(e[r+M]-e[r+_])+(e[r+ee]-e[r+$])*(e[r+ee]-e[r+$])),Ge=Math.sqrt((e[r+M]+e[r+_])*(e[r+M]+e[r+_])+(e[r+ee]+e[r+$])*(e[r+ee]+e[r+$]))/2,ue=.1*Math.log(1+Ge)/(1+Math.sqrt(ye)),De=e[r+U]+e[r+_]*(ue/t.slowDown),e[r+U]=De,ke=e[r+B]+e[r+$]*(ue/t.slowDown),e[r+B]=ke);else for(r=0;r<E;r+=J)e[r+Xe]!==1&&(ye=e[r+D]*Math.sqrt((e[r+M]-e[r+_])*(e[r+M]-e[r+_])+(e[r+ee]-e[r+$])*(e[r+ee]-e[r+$])),Ge=Math.sqrt((e[r+M]+e[r+_])*(e[r+M]+e[r+_])+(e[r+ee]+e[r+$])*(e[r+ee]+e[r+$]))/2,ue=e[r+Qe]*Math.log(1+Ge)/(1+Math.sqrt(ye)),e[r+Qe]=Math.min(1,Math.sqrt(ue*(Math.pow(e[r+_],2)+Math.pow(e[r+$],2))/(1+Math.sqrt(ye)))),De=e[r+U]+e[r+_]*(ue/t.slowDown),e[r+U]=De,ke=e[r+B]+e[r+$]*(ue/t.slowDown),e[r+B]=ke);return{}},re={},Ee=10,et=3;re.assign=function(i){i=i||{};var t=Array.prototype.slice.call(arguments).slice(1),e,n,s;for(e=0,s=t.length;e<s;e++)if(!!t[e])for(n in t[e])i[n]=t[e][n];return i};re.validateSettings=function(i){return"linLogMode"in i&&typeof i.linLogMode!="boolean"?{message:"the `linLogMode` setting should be a boolean."}:"outboundAttractionDistribution"in i&&typeof i.outboundAttractionDistribution!="boolean"?{message:"the `outboundAttractionDistribution` setting should be a boolean."}:"adjustSizes"in i&&typeof i.adjustSizes!="boolean"?{message:"the `adjustSizes` setting should be a boolean."}:"edgeWeightInfluence"in i&&typeof i.edgeWeightInfluence!="number"?{message:"the `edgeWeightInfluence` setting should be a number."}:"scalingRatio"in i&&!(typeof i.scalingRatio=="number"&&i.scalingRatio>=0)?{message:"the `scalingRatio` setting should be a number >= 0."}:"strongGravityMode"in i&&typeof i.strongGravityMode!="boolean"?{message:"the `strongGravityMode` setting should be a boolean."}:"gravity"in i&&!(typeof i.gravity=="number"&&i.gravity>=0)?{message:"the `gravity` setting should be a number >= 0."}:"slowDown"in i&&!(typeof i.slowDown=="number"||i.slowDown>=0)?{message:"the `slowDown` setting should be a number >= 0."}:"barnesHutOptimize"in i&&typeof i.barnesHutOptimize!="boolean"?{message:"the `barnesHutOptimize` setting should be a boolean."}:"barnesHutTheta"in i&&!(typeof i.barnesHutTheta=="number"&&i.barnesHutTheta>=0)?{message:"the `barnesHutTheta` setting should be a number >= 0."}:null};re.graphToByteArrays=function(i,t){var e=i.order,n=i.size,s={},o,r=new Float32Array(e*Ee),u=new Float32Array(n*et);return o=0,i.forEachNode(function(a,d){s[a]=o,r[o]=d.x,r[o+1]=d.y,r[o+2]=0,r[o+3]=0,r[o+4]=0,r[o+5]=0,r[o+6]=1,r[o+7]=1,r[o+8]=d.size||1,r[o+9]=d.fixed?1:0,o+=Ee}),o=0,i.forEachEdge(function(a,d,l,c,h,y,E){var L=s[l],S=s[c],F=t(a,d,l,c,h,y,E);r[L+6]+=F,r[S+6]+=F,u[o]=L,u[o+1]=S,u[o+2]=F,o+=et}),{nodes:r,edges:u}};re.assignLayoutChanges=function(i,t,e){var n=0;i.updateEachNodeAttributes(function(s,o){return o.x=t[n],o.y=t[n+1],n+=Ee,e?e(s,o):o})};re.readGraphPositions=function(i,t){var e=0;i.forEachNode(function(n,s){t[e]=s.x,t[e+1]=s.y,e+=Ee})};re.collectLayoutChanges=function(i,t,e){for(var n=i.nodes(),s={},o=0,r=0,u=t.length;o<u;o+=Ee){if(e){var a=Object.assign({},i.getNodeAttributes(n[r]));a.x=t[o],a.y=t[o+1],a=e(n[r],a),s[n[r]]={x:a.x,y:a.y}}else s[n[r]]={x:t[o],y:t[o+1]};r++}return s};re.createWorker=function(t){var e=window.URL||window.webkitURL,n=t.toString(),s=e.createObjectURL(new Blob(["("+n+").call(this);"],{type:"text/javascript"})),o=new Worker(s);return e.revokeObjectURL(s),o};var fi={linLogMode:!1,outboundAttractionDistribution:!1,adjustSizes:!1,edgeWeightInfluence:1,scalingRatio:1,strongGravityMode:!1,gravity:1,slowDown:1,barnesHutOptimize:!1,barnesHutTheta:.5},li=At,pi=Fe.createEdgeWeightGetter,gi=ci,be=re,yi=fi;function Bt(i,t,e){if(!li(t))throw new Error("graphology-layout-forceatlas2: the given graph is not a valid graphology instance.");typeof e=="number"&&(e={iterations:e});var n=e.iterations;if(typeof n!="number")throw new Error("graphology-layout-forceatlas2: invalid number of iterations.");if(n<=0)throw new Error("graphology-layout-forceatlas2: you should provide a positive number of iterations.");var s=pi("getEdgeWeight"in e?e.getEdgeWeight:"weight").fromEntry,o=typeof e.outputReducer=="function"?e.outputReducer:null,r=be.assign({},yi,e.settings),u=be.validateSettings(r);if(u)throw new Error("graphology-layout-forceatlas2: "+u.message);var a=be.graphToByteArrays(t,s),d;for(d=0;d<n;d++)gi(r,a.nodes,a.edges);if(i){be.assignLayoutChanges(t,a.nodes,o);return}return be.collectLayoutChanges(t,a.nodes)}function wi(i){var t=typeof i=="number"?i:i.order;return{barnesHutOptimize:t>2e3,strongGravityMode:!0,gravity:.05,scalingRatio:10,slowDown:1+Math.log(t)}}var Ke=Bt.bind(null,!1);Ke.assign=Bt.bind(null,!0);Ke.inferSettings=wi;var mi=Ke;const vi=()=>{const i=He.exports.useRef(null),t={debug:!1,lineUseTextPath:!0,layout:{layoutName:"fixed"},defaultNodeShape:0,defaultLineShape:1,defaultJunctionPoint:"border",defaultNodeBorderWidth:0,defaultNodeWidth:30,defaultNodeHeight:30,defaultLineColor:"rgba(0, 186, 189, 1)",defaultNodeColor:"rgba(0, 206, 209, 1)"},e=async()=>{let o={rootId:"root",nodes:[{id:"root",text:"\u8282\u70B9"},{id:"N2",text:"\u65B0\u8282\u70B9N2"},{id:"N3",text:"\u65B0\u8282\u70B9N3"},{id:"N4",text:"\u65B0\u8282\u70B9N4"},{id:"N5",text:"\u65B0\u8282\u70B9N5"},{id:"N6",text:"\u65B0\u8282\u70B9N6"},{id:"N7",text:"\u65B0\u8282\u70B9N7"},{id:"N8",text:"\u65B0\u8282\u70B9N8"},{id:"N9",text:"\u65B0\u8282\u70B9N9"},{id:"N10",text:"\u65B0\u8282\u70B9N10"},{id:"N11",text:"\u65B0\u8282\u70B9N11"},{id:"N12",text:"\u65B0\u8282\u70B9N12"},{id:"N13",text:"\u65B0\u8282\u70B9N13"},{id:"N14",text:"\u65B0\u8282\u70B9N14"},{id:"N15",text:"\u65B0\u8282\u70B9N15"},{id:"N16",text:"\u65B0\u8282\u70B9N16"},{id:"N17",text:"\u65B0\u8282\u70B9N17"},{id:"N18",text:"\u65B0\u8282\u70B9N18"},{id:"N19",text:"\u65B0\u8282\u70B9N19"},{id:"N20",text:"\u65B0\u8282\u70B9N20"},{id:"N21",text:"\u65B0\u8282\u70B9N21"},{id:"N22",text:"\u65B0\u8282\u70B9N22"},{id:"N23",text:"\u65B0\u8282\u70B9N23"},{id:"N24",text:"\u65B0\u8282\u70B9N24"},{id:"N25",text:"\u65B0\u8282\u70B9N25"},{id:"N26",text:"\u65B0\u8282\u70B9N26"},{id:"N27",text:"New-N27"},{id:"N28",text:"New-N28"},{id:"N29",text:"New-N29"},{id:"N30",text:"New-N30"},{id:"N31",text:"New-N31"},{id:"N32",text:"New-N32"},{id:"N33",text:"New-N33"},{id:"N34",text:"New-N34"},{id:"N35",text:"New-N35"},{id:"N36",text:"New-N36"},{id:"N37",text:"New-N37"},{id:"N38",text:"New-N38"},{id:"N39",text:"New-N39"}],lines:[{from:"N3",to:"N2",text:"\u65B0\u8FDE\u7EBF1"},{from:"N2",to:"root",text:"\u65B0\u8FDE\u7EBF1"},{from:"root",to:"N4",text:"\u65B0\u8FDE\u7EBF2"},{from:"N4",to:"N5",text:"\u65B0\u8FDE\u7EBF3"},{from:"N6",to:"N7",text:"\u65B0\u8FDE\u7EBF2"},{from:"N7",to:"root",text:"\u65B0\u8FDE\u7EBF3"},{from:"N8",to:"N9",text:"\u65B0\u8FDE\u7EBF4"},{from:"N9",to:"root",text:"\u65B0\u8FDE\u7EBF5"},{from:"N10",to:"N11",text:"\u65B0\u8FDE\u7EBF6"},{from:"N11",to:"root",text:"\u65B0\u8FDE\u7EBF7"},{from:"N13",to:"N12",text:"\u65B0\u8FDE\u7EBF8"},{from:"N12",to:"root",text:"\u65B0\u8FDE\u7EBF9"},{from:"N18",to:"N17",text:"\u65B0\u8FDE\u7EBF10"},{from:"N17",to:"N14",text:"\u65B0\u8FDE\u7EBF11"},{from:"N15",to:"N14",text:"\u65B0\u8FDE\u7EBF12"},{from:"N16",to:"N15",text:"\u65B0\u8FDE\u7EBF13"},{from:"N12",to:"N14",text:"\u65B0\u8FDE\u7EBF14"},{from:"N20",to:"N19",text:"\u65B0\u8FDE\u7EBF15"},{from:"N21",to:"N19",text:"\u65B0\u8FDE\u7EBF16"},{from:"N19",to:"N15",text:"\u65B0\u8FDE\u7EBF17"},{from:"N26",to:"N22",text:"\u65B0\u8FDE\u7EBF18"},{from:"N24",to:"N25",text:"\u65B0\u8FDE\u7EBF19"},{from:"N24",to:"N22",text:"\u65B0\u8FDE\u7EBF20"},{from:"N22",to:"N23",text:"\u65B0\u8FDE\u7EBF21"},{from:"N23",to:"N14",text:"\u65B0\u8FDE\u7EBF22"},{from:"root",to:"N30",text:"\u65B0\u8FDE\u7EBF1"},{from:"root",to:"N27",text:"\u65B0\u8FDE\u7EBF2"},{from:"N30",to:"N33",text:"\u65B0\u8FDE\u7EBF3"},{from:"N30",to:"N29",text:"\u65B0\u8FDE\u7EBF4"},{from:"N27",to:"N28",text:"\u65B0\u8FDE\u7EBF5"},{from:"N27",to:"N31",text:"\u65B0\u8FDE\u7EBF6"},{from:"N27",to:"N32",text:"\u65B0\u8FDE\u7EBF7"},{from:"N4",to:"N34",text:"\u65B0\u8FDE\u7EBF8"},{from:"N28",to:"N35",text:"\u65B0\u8FDE\u7EBF9"},{from:"N28",to:"N36",text:"\u65B0\u8FDE\u7EBF12"},{from:"N28",to:"N37",text:"\u65B0\u8FDE\u7EBF13"},{from:"N36",to:"N39",text:"\u65B0\u8FDE\u7EBF14"},{from:"N36",to:"N38",text:"\u65B0\u8FDE\u7EBF15"}]};o.nodes.forEach(a=>{a.text="N"});const r=new N,u=i.current.getInstance();await u.setJsonData(o),u.getNodes().forEach(a=>{r.addNode(a.id,{text:a.text,width:a.el.offsetWidth,height:a.el.offsetHeight})}),u.getLinks().forEach(a=>{a.relations.forEach(d=>{r.addEdge(a.fromNode.id,a.toNode.id,{id:d.id,weight:1})})}),ri.assign(r),mi.assign(r,50),r.nodes().forEach(a=>{const d=r.getNodeAttributes(a),l=u.getNodeById(a);l.x=d.x*10,l.y=d.y*10})},n=(o,r)=>{console.log("onNodeClick:",o)},s=(o,r,u)=>{console.log("onLineClick:",o)};return He.exports.useEffect(()=>{e()},[]),Ae("div",{children:xt("div",{style:{height:"100vh"},children:[Ae("div",{className:"w-96 rounded-lg absolute left-20 top-20 z-20 p-4 bg-white border-solid border-2 border-black shadow-lg",children:Ae("div",{className:"c-option-name leading-12 p-3",children:"This layout uses a third-party layout algorithm: Sigma, and you can still use powerful features such as slot support in relation-graph, perfect integration. Sigma force-directed graph layout is a classic layout algorithm."})}),Ae(Ft,{ref:i,options:t,onNodeClick:n,onLineClick:s})]})})};export{vi as default};
